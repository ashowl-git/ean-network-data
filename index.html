<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>EAN 계약 네트워크</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: #fafafa;
            color: #333333;
            overflow: hidden;
            line-height: 1.4;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .graph-container {
            flex: 1;
            position: relative;
            background: #fafafa;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-input {
            width: 100%;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-radius: 6px;
            color: #374151;
            font-size: 14px;
            transition: all 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: #333333;
            background: rgba(255, 255, 255, 1);
        }

        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .filter-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-radius: 4px;
            color: #374151;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .filter-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
        }

        .filter-btn.active {
            background: #333333;
            border-color: #333333;
            color: #ffffff;
        }


        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .stat-value {
            font-weight: 600;
            color: #3b82f6;
        }


        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #ffffff;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            color: #999999;
        }

        .spinner {
            border: 2px solid #e0e0e0;
            border-top: 2px solid #333333;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .node {
            cursor: pointer;
            stroke-width: 2px;
            transition: all 0.3s ease;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        .node:hover {
            stroke-width: 4px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        }

        .node.blurred {
            opacity: 0.2;
            filter: blur(1px);
        }

        .node.highlighted {
            opacity: 1;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
        }

        .link {
            stroke: #cbd5e1;
            stroke-opacity: 0.6;
            stroke-width: 1px;
            transition: all 0.3s ease;
        }

        .link.blurred {
            opacity: 0.1;
        }

        .link.highlighted {
            stroke: #3b82f6;
            stroke-opacity: 0.8;
            stroke-width: 2px;
        }

        .node-label {
            font-size: 11px;
            fill: #374151;
            text-anchor: middle;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            font-weight: 500;
        }

        .node-label.visible {
            opacity: 1;
        }

        .node-label.service-highlighted {
            opacity: 1;
            font-size: 12px;
            font-weight: 600;
            fill: #111827;
            filter: drop-shadow(0 1px 2px rgba(255, 255, 255, 0.8));
        }

        .node.service-selected {
            stroke-width: 4px;
            stroke: #059669;
            filter: drop-shadow(0 3px 8px rgba(16, 185, 129, 0.4));
        }

        .tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            color: #374151;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip strong {
            color: #111827;
            font-weight: 600;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 100;
        }

        .zoom-btn {
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-1px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.18);
        }

        .clear-selection {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px 16px;
            background: rgba(239, 68, 68, 0.9);
            backdrop-filter: blur(16px);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            opacity: 0;
            pointer-events: none;
        }

        .clear-selection.visible {
            opacity: 1;
            pointer-events: all;
        }

        .clear-selection:hover {
            background: #dc2626;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* 플로팅 컨트롤 패널 */
        .floating-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 280px;
            transition: all 0.3s ease;
        }

        .floating-controls:hover {
            background: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
        }

        /* 플로팅 오버레이 카드 */
        .overlay-cards {
            position: absolute;
            top: 20px;
            right: 80px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none;
        }

        .overlay-card {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            pointer-events: all;
            width: 300px;
            transition: all 0.3s ease;
        }

        .overlay-card:hover {
            background: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
            transform: translateY(-1px);
        }

        .overlay-card h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #111827;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .service-controls {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
        }

        .service-control-btn {
            padding: 6px 10px;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            color: #374151;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .service-control-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        .service-control-btn.active {
            background: #333333;
            border-color: #333333;
            color: #ffffff;
        }

        .service-list {
            max-height: 240px;
            overflow-y: auto;
        }

        .service-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f3f4f6;
            transition: all 0.2s;
        }

        .service-item:last-child {
            border-bottom: none;
        }

        .service-item:hover {
            background: #f9fafb;
            border-radius: 6px;
            padding: 8px 8px;
            margin: 0 -8px;
        }

        .service-checkbox {
            margin-right: 10px;
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #10b981;
        }

        .service-label {
            flex: 1;
            font-size: 13px;
            color: #374151;
            cursor: pointer;
            line-height: 1.4;
        }

        .service-label.selected {
            font-weight: 600;
            color: #10b981;
        }

        .service-count {
            font-size: 11px;
            color: #6b7280;
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
        }

        .service-item.highlighted .service-count {
            background: #10b981;
            color: #ffffff;
        }

        .service-search {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-radius: 4px;
            color: #374151;
            font-size: 12px;
            margin-bottom: 10px;
            transition: all 0.2s;
        }

        .service-search:focus {
            outline: none;
            border-color: #333333;
            background: rgba(255, 255, 255, 1);
        }

        /* 반응형 디자인 */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                height: 250px;
                overflow-y: auto;
            }
            
            .container {
                flex-direction: column;
            }
            
            .graph-container {
                height: calc(100vh - 250px);
            }
            
            .zoom-controls {
                top: 10px;
                right: 10px;
            }

            .service-browser {
                max-height: 150px;
            }
        }

        @media (max-width: 480px) {
            .sidebar {
                height: 160px;
                padding: 12px;
            }
            
            .graph-container {
                height: calc(100vh - 160px);
            }
            
            .control-group {
                margin-bottom: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        
        <div class="graph-container">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>데이터를 불러오는 중...</div>
            </div>
            
            <!-- 플로팅 컨트롤 패널 -->
            <div class="floating-controls">
                <div class="control-group">
                    <label>검색</label>
                    <input type="text" class="search-input" id="searchInput" placeholder="계약명, 수행용역 검색...">
                </div>
                
                <div class="control-group">
                    <label>연도 필터</label>
                    <div class="filter-buttons" id="yearFilters"></div>
                </div>
                
                <div class="control-group">
                    <label>노드 타입</label>
                    <div class="filter-buttons" id="nodeTypeFilters">
                        <button class="filter-btn active" data-type="all">전체</button>
                        <button class="filter-btn" data-type="contract-only">계약명만</button>
                        <button class="filter-btn" data-type="service-only">수행용역만</button>
                    </div>
                </div>
            </div>
            
            <!-- 플로팅 오버레이 카드들 -->
            <div class="overlay-cards">
                <div class="overlay-card">
                    <h3>
                        수행용역
                        <span id="selectedServiceCount" style="font-size: 12px; color: #6b7280;">0/43</span>
                    </h3>
                    
                    <input type="text" class="service-search" id="serviceSearch" placeholder="수행용역 검색...">
                    
                    <div class="service-controls">
                        <button class="service-control-btn" id="selectAllServices">모두 선택</button>
                        <button class="service-control-btn" id="clearAllServices">모두 해제</button>
                        <button class="service-control-btn" id="showSelectedOnly">선택만 보기</button>
                    </div>
                    
                    <div class="service-list" id="serviceList">
                        <!-- 수행용역 리스트가 여기에 동적으로 생성됩니다 -->
                    </div>
                </div>
                
                <div class="overlay-card">
                    <h3>범례</h3>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3b82f6;"></div>
                        <span>계약명</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #10b981;"></div>
                        <span>수행용역</span>
                    </div>
                </div>
                
                <div class="overlay-card">
                    <h3>통계</h3>
                    <div class="stat-item">
                        <span>총 노드:</span>
                        <span class="stat-value" id="totalNodes">0</span>
                    </div>
                    <div class="stat-item">
                        <span>연결:</span>
                        <span class="stat-value" id="totalLinks">0</span>
                    </div>
                    <div class="stat-item">
                        <span>표시된 노드:</span>
                        <span class="stat-value" id="visibleNodes">0</span>
                    </div>
                    <div class="stat-item">
                        <span>연도 범위:</span>
                        <span class="stat-value" id="yearRange">-</span>
                    </div>
                </div>
            </div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomIn">+</button>
                <button class="zoom-btn" id="zoomOut">−</button>
                <button class="zoom-btn" id="resetZoom">⌂</button>
            </div>
            
            <button class="clear-selection" id="clearSelection">선택 해제</button>
            
            <svg id="graph"></svg>
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        // 전역 변수
        let allData = [];
        let filteredData = [];
        let nodes = [];
        let links = [];
        let simulation;
        let svg, g;
        let width, height;
        let zoom;
        let selectedNode = null;
        let currentScale = 1;
        let selectedServices = new Set();
        let allServices = [];
        let showSelectedOnly = false;

        // 색상 스키마 (눈의 피로 감소를 위한 부드러운 색상)
        const colors = {
            contract: '#3b82f6',    // 파란색 - 계약명
            service: '#10b981'      // 초록색 - 수행용역
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await loadData();
                initGraph();
                setupEventListeners();
                updateStats();
            } catch (error) {
                console.error('초기화 오류:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ef4444;">❌ 데이터 로딩 실패</div>
                    <div style="font-size: 12px; margin-top: 10px;">CSV 파일을 확인해주세요.</div>
                `;
            }
        });

        // 최적화된 데이터 로드 (JSON 우선, CSV 폴백)
        async function loadData() {
            try {
                // JSON 파일 로드 시도
                console.log('JSON 데이터 로드 중...');
                const startTime = performance.now();
                
                const response = await fetch('data.json');
                const jsonData = await response.json();
                
                console.log(`JSON 로드 완료: ${jsonData.records.length.toLocaleString()}개 레코드`);
                
                // 인덱스를 실제 값으로 변환
                allData = jsonData.records.map(record => ({
                    year: jsonData.lookup.years[record[0]],
                    contract: jsonData.lookup.contracts[record[1]], 
                    service: jsonData.lookup.services[record[2]]
                }));
                
                const endTime = performance.now();
                console.log(`JSON 파싱 완료: ${allData.length.toLocaleString()}개 항목 (${(endTime - startTime).toFixed(1)}ms)`);
                
            } catch (error) {
                console.warn('JSON 로드 실패, CSV로 폴백:', error);
                // CSV 폴백
                await loadDataCSV();
            }

            filteredData = [...allData];
            createNetworkData();
            
            // 연도 필터는 초기 로드 시에만 생성
            createYearFilters();
            
            // 수행용역 브라우저 초기화
            initializeServiceBrowser();
        }

        // CSV 폴백 함수
        async function loadDataCSV() {
            console.log('CSV 데이터 로드 중...');
            const startTime = performance.now();
            
            const response = await fetch('202508_EAN계약현황_완전본.csv');
            const text = await response.text();
            
            // CSV 파싱
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',');
            
            allData = lines.slice(1).map(line => {
                const values = parseCSVLine(line);
                return {
                    year: values[0]?.trim() || '',
                    contract: values[1]?.trim() || '',
                    service: values[2]?.trim() || ''
                };
            }).filter(d => d.year && d.contract && d.service);

            const endTime = performance.now();
            console.log(`CSV 파싱 완료: ${allData.length.toLocaleString()}개 항목 (${(endTime - startTime).toFixed(1)}ms)`);
        }

        // CSV 라인 파싱 (따옴표 처리)
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            
            return result;
        }

        // 네트워크 데이터 생성 (발주처 제거됨)
        function createNetworkData() {
            const nodeMap = new Map();
            const linkMap = new Map();

            // 노드 생성
            filteredData.forEach(d => {
                // 계약명 노드
                if (!nodeMap.has(d.contract)) {
                    nodeMap.set(d.contract, {
                        id: d.contract,
                        type: 'contract',
                        year: d.year,
                        connections: 0
                    });
                }

                // 수행용역 노드
                if (!nodeMap.has(d.service)) {
                    nodeMap.set(d.service, {
                        id: d.service,
                        type: 'service',
                        connections: 0
                    });
                }

                // 링크 생성 (계약명 - 수행용역만)
                const linkId = d.contract < d.service ? `${d.contract}|${d.service}` : `${d.service}|${d.contract}`;
                if (!linkMap.has(linkId)) {
                    linkMap.set(linkId, {
                        source: d.contract,
                        target: d.service,
                        weight: 1
                    });
                    nodeMap.get(d.contract).connections++;
                    nodeMap.get(d.service).connections++;
                } else {
                    linkMap.get(linkId).weight++;
                }
            });

            nodes = Array.from(nodeMap.values());
            links = Array.from(linkMap.values());
        }

        // 연도 필터 생성
        let yearFiltersCreated = false;
        function createYearFilters() {
            if (yearFiltersCreated) return;
            
            const years = [...new Set(allData.map(d => d.year))].sort();
            const yearFilters = document.getElementById('yearFilters');
            
            yearFilters.innerHTML = '';
            
            // 전체 버튼
            const allBtn = document.createElement('button');
            allBtn.className = 'filter-btn active';
            allBtn.textContent = '전체';
            allBtn.dataset.year = 'all';
            yearFilters.appendChild(allBtn);

            // 연도별 버튼
            years.forEach(year => {
                const btn = document.createElement('button');
                btn.className = 'filter-btn';
                btn.textContent = year;
                btn.dataset.year = year;
                yearFilters.appendChild(btn);
            });

            // 통계 업데이트
            const minYear = Math.min(...years.map(y => parseInt(y)));
            const maxYear = Math.max(...years.map(y => parseInt(y)));
            document.getElementById('yearRange').textContent = `${minYear} - ${maxYear}`;
            
            yearFiltersCreated = true;
        }

        // 그래프 초기화
        function initGraph() {
            const container = document.querySelector('.graph-container');
            width = container.clientWidth;
            height = container.clientHeight;

            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);

            // 줌 설정
            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                    currentScale = event.transform.k;
                    // 확대 시 라벨 표시
                    updateLabelsVisibility();
                });

            svg.call(zoom);
            g = svg.append('g');

            // 시뮬레이션 설정
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-400))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => getNodeSize(d) + 4));

            renderGraph();
            document.getElementById('loading').style.display = 'none';
        }

        // 그래프 렌더링
        function renderGraph() {
            // 기존 요소 제거
            g.selectAll('*').remove();

            // 링크 그리기
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke-width', d => Math.sqrt(d.weight) + 1);

            // 노드 그리기
            const node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => getNodeSize(d))
                .attr('fill', d => colors[d.type])
                .attr('stroke', d => d3.color(colors[d.type]).darker())
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // 라벨 추가
            const label = g.append('g')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .attr('class', 'node-label')
                .attr('dy', d => getNodeSize(d) + 18)
                .text(d => truncateText(d.id, 25));

            // 이벤트 리스너
            node
                .on('mouseover', (event, d) => {
                    showTooltip(event, d);
                })
                .on('mouseout', () => {
                    hideTooltip();
                })
                .on('click', (event, d) => {
                    event.stopPropagation();
                    selectNode(d);
                });

            // 배경 클릭 시 선택 해제
            svg.on('click', () => {
                clearSelection();
            });

            // 시뮬레이션 업데이트
            simulation.nodes(nodes);
            simulation.force('link').links(links);

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            simulation.alpha(1).restart();
        }

        // 노드 크기 계산 (연결 수에 따라 크기 조정)
        function getNodeSize(d) {
            const baseSize = 6;
            const connectionFactor = Math.sqrt(d.connections) * 1.5;
            return Math.max(baseSize, Math.min(baseSize + connectionFactor, 30));
        }

        // 노드 선택 및 블러 효과
        function selectNode(targetNode) {
            selectedNode = targetNode;
            
            // 연결된 노드들 찾기
            const connectedNodes = new Set([targetNode.id]);
            const connectedLinks = new Set();
            
            links.forEach(link => {
                if (link.source.id === targetNode.id || link.target.id === targetNode.id) {
                    connectedNodes.add(link.source.id);
                    connectedNodes.add(link.target.id);
                    connectedLinks.add(link);
                }
            });

            // 노드 스타일 적용
            g.selectAll('.node')
                .classed('blurred', d => !connectedNodes.has(d.id))
                .classed('highlighted', d => connectedNodes.has(d.id));

            // 링크 스타일 적용
            g.selectAll('.link')
                .classed('blurred', d => !connectedLinks.has(d))
                .classed('highlighted', d => connectedLinks.has(d));

            // 선택 해제 버튼 표시
            document.getElementById('clearSelection').classList.add('visible');
        }

        // 선택 해제 (수행용역 선택도 해제)
        function clearSelection() {
            selectedNode = null;
            
            // 수행용역 선택도 해제
            selectedServices.clear();
            showSelectedOnly = false;
            document.getElementById('showSelectedOnly').classList.remove('active');
            document.getElementById('showSelectedOnly').textContent = '선택만 보기';
            
            g.selectAll('.node')
                .classed('blurred', false)
                .classed('highlighted', false)
                .classed('service-selected', false)
                .style('display', null);

            g.selectAll('.link')
                .classed('blurred', false)
                .classed('highlighted', false)
                .style('display', null);
                
            g.selectAll('.node-label')
                .classed('service-highlighted', false);

            document.getElementById('clearSelection').classList.remove('visible');
            
            // 수행용역 브라우저 업데이트
            updateServiceCount();
            renderServiceList();
        }

        // 확대 시 라벨 표시 (수행용역은 항상 표시)
        function updateLabelsVisibility() {
            const showLabels = currentScale > 1.5;
            g.selectAll('.node-label')
                .classed('visible', function(d) {
                    return showLabels || d.type === 'service';
                });
        }

        // 텍스트 자르기
        function truncateText(text, maxLength) {
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
        }

        // 툴팁 표시
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const rect = document.querySelector('.graph-container').getBoundingClientRect();
            
            tooltip.innerHTML = `
                <strong>${d.id}</strong><br>
                타입: ${getTypeLabel(d.type)}<br>
                연결: ${d.connections}개
                ${d.year ? `<br>연도: ${d.year}` : ''}
            `;
            
            tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
            tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
            tooltip.classList.add('visible');
        }

        // 툴팁 숨기기
        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        // 타입 라벨 반환
        function getTypeLabel(type) {
            const labels = {
                contract: '계약명',
                service: '수행용역'
            };
            return labels[type] || type;
        }

        // 드래그 이벤트
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            // 검색 (수행용역 필터와 연동)
            document.getElementById('searchInput').addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                
                // 수행용역 검색 결과도 업데이트
                if (query) {
                    // 검색어와 매칭되는 수행용역 자동 하이라이트
                    const matchingServices = allServices.filter(service => 
                        service.toLowerCase().includes(query)
                    );
                    
                    if (matchingServices.length > 0 && matchingServices.length <= 3) {
                        // 매칭되는 수행용역이 3개 이하면 자동 선택
                        selectedServices.clear();
                        matchingServices.forEach(service => selectedServices.add(service));
                        updateServiceHighlighting();
                        updateServiceCount();
                        renderServiceList();
                    }
                } else {
                    // 검색어가 비어있으면 수행용역 선택 해제
                    if (selectedServices.size > 0) {
                        selectedServices.clear();
                        updateServiceHighlighting();
                        updateServiceCount();
                        renderServiceList();
                    }
                }
                
                applyFilters();
            });

            // 연도 필터
            document.getElementById('yearFilters').addEventListener('click', (e) => {
                if (e.target.classList.contains('filter-btn')) {
                    document.querySelectorAll('#yearFilters .filter-btn').forEach(btn => 
                        btn.classList.remove('active')
                    );
                    e.target.classList.add('active');
                    applyFilters();
                }
            });

            // 노드 타입 필터 (수정됨 - 발주처 제거)
            document.getElementById('nodeTypeFilters').addEventListener('click', (e) => {
                if (e.target.classList.contains('filter-btn')) {
                    document.querySelectorAll('#nodeTypeFilters .filter-btn').forEach(btn => 
                        btn.classList.remove('active')
                    );
                    e.target.classList.add('active');
                    applyFilters();
                }
            });

            // 줌 컨트롤
            document.getElementById('zoomIn').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 1.2);
            });

            document.getElementById('zoomOut').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 0.8);
            });

            document.getElementById('resetZoom').addEventListener('click', () => {
                svg.transition().call(zoom.transform, d3.zoomIdentity);
            });

            // 선택 해제 버튼
            document.getElementById('clearSelection').addEventListener('click', () => {
                clearSelection();
            });

            // 윈도우 리사이즈
            window.addEventListener('resize', () => {
                const container = document.querySelector('.graph-container');
                width = container.clientWidth;
                height = container.clientHeight;
                
                svg.attr('width', width).attr('height', height);
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();
            });
        }

        // 필터 적용
        function applyFilters() {
            const searchQuery = document.getElementById('searchInput').value.toLowerCase();
            const activeYear = document.querySelector('#yearFilters .filter-btn.active')?.dataset.year;
            const activeType = document.querySelector('#nodeTypeFilters .filter-btn.active')?.dataset.type;

            // 데이터 필터링
            filteredData = allData.filter(d => {
                const matchesSearch = !searchQuery || 
                    d.contract.toLowerCase().includes(searchQuery) ||
                    d.service.toLowerCase().includes(searchQuery);

                const matchesYear = activeYear === 'all' || d.year === activeYear;

                return matchesSearch && matchesYear;
            });

            // 네트워크 데이터 재생성
            createNetworkData();

            // 노드 타입 필터링
            if (activeType !== 'all') {
                let allowedTypes = [];
                
                switch(activeType) {
                    case 'contract-only':
                        allowedTypes = ['contract'];
                        break;
                    case 'service-only':
                        allowedTypes = ['service'];
                        break;
                }
                
                nodes = nodes.filter(node => allowedTypes.includes(node.type));
                links = links.filter(link => {
                    const sourceNode = nodes.find(n => n.id === link.source);
                    const targetNode = nodes.find(n => n.id === link.target);
                    return sourceNode && targetNode;
                });
            }

            // 선택 해제
            clearSelection();

            // 그래프 재렌더링
            renderGraph();
            updateStats();
        }

        // 통계 업데이트
        function updateStats() {
            document.getElementById('totalNodes').textContent = nodes.length.toLocaleString();
            document.getElementById('totalLinks').textContent = links.length.toLocaleString();
            document.getElementById('visibleNodes').textContent = nodes.length.toLocaleString();
        }

        // 수행용역 브라우저 초기화
        function initializeServiceBrowser() {
            // 모든 수행용역 추출 및 정렬
            const serviceSet = new Set();
            allData.forEach(d => {
                if (d.service && d.service.trim()) {
                    serviceSet.add(d.service.trim());
                }
            });
            
            allServices = Array.from(serviceSet).sort((a, b) => a.localeCompare(b, 'ko'));
            
            console.log(`수행용역 ${allServices.length}개 추출 완료:`, allServices);
            
            // 수행용역 리스트 렌더링
            renderServiceList();
            
            // 이벤트 리스너 설정
            setupServiceBrowserEvents();
            
            // 카운트 업데이트
            updateServiceCount();
        }

        // 수행용역 리스트 렌더링
        function renderServiceList(searchQuery = '') {
            const serviceList = document.getElementById('serviceList');
            const filteredServices = allServices.filter(service => 
                service.toLowerCase().includes(searchQuery.toLowerCase())
            );
            
            serviceList.innerHTML = '';
            
            filteredServices.forEach(service => {
                // 해당 수행용역과 연결된 계약 수 계산
                const contractCount = allData.filter(d => d.service === service).length;
                
                const serviceItem = document.createElement('div');
                serviceItem.className = 'service-item';
                serviceItem.innerHTML = `
                    <input type="checkbox" class="service-checkbox" data-service="${service}" ${selectedServices.has(service) ? 'checked' : ''}>
                    <span class="service-label ${selectedServices.has(service) ? 'selected' : ''}">${service}</span>
                    <span class="service-count">${contractCount}</span>
                `;
                
                if (selectedServices.has(service)) {
                    serviceItem.classList.add('highlighted');
                }
                
                serviceList.appendChild(serviceItem);
            });
        }

        // 수행용역 브라우저 이벤트 설정
        function setupServiceBrowserEvents() {
            // 검색 기능
            const serviceSearch = document.getElementById('serviceSearch');
            serviceSearch.addEventListener('input', (e) => {
                const query = e.target.value;
                renderServiceList(query);
                
                // 검색 결과에 따른 플레이스홀더 업데이트
                const matchingCount = allServices.filter(service => 
                    service.toLowerCase().includes(query.toLowerCase())
                ).length;
                
                if (query && matchingCount === 0) {
                    e.target.style.borderColor = '#ef4444';
                    e.target.placeholder = '일치하는 수행용역이 없습니다';
                } else {
                    e.target.style.borderColor = query ? '#10b981' : '#d1d5db';
                    e.target.placeholder = query ? `${matchingCount}개 수행용역 발견` : '수행용역 검색...';
                }
            });

            // 체크박스 클릭 이벤트 (이벤트 위임)
            const serviceList = document.getElementById('serviceList');
            serviceList.addEventListener('change', (e) => {
                if (e.target.classList.contains('service-checkbox')) {
                    const service = e.target.dataset.service;
                    const isChecked = e.target.checked;
                    
                    if (isChecked) {
                        selectedServices.add(service);
                    } else {
                        selectedServices.delete(service);
                    }
                    
                    updateServiceHighlighting();
                    updateServiceCount();
                    renderServiceList(serviceSearch.value);
                }
            });

            // 라벨 클릭으로 체크박스 토글
            serviceList.addEventListener('click', (e) => {
                if (e.target.classList.contains('service-label')) {
                    const checkbox = e.target.parentElement.querySelector('.service-checkbox');
                    checkbox.click();
                }
            });

            // 컨트롤 버튼들
            document.getElementById('selectAllServices').addEventListener('click', () => {
                allServices.forEach(service => selectedServices.add(service));
                updateServiceHighlighting();
                updateServiceCount();
                renderServiceList(serviceSearch.value);
            });

            document.getElementById('clearAllServices').addEventListener('click', () => {
                selectedServices.clear();
                updateServiceHighlighting();
                updateServiceCount();
                renderServiceList(serviceSearch.value);
            });

            document.getElementById('showSelectedOnly').addEventListener('click', (e) => {
                showSelectedOnly = !showSelectedOnly;
                e.target.classList.toggle('active');
                e.target.textContent = showSelectedOnly ? '모두 보기' : '선택만 보기';
                updateServiceHighlighting();
            });
        }

        // 선택된 수행용역 수 업데이트
        function updateServiceCount() {
            const count = selectedServices.size;
            const total = allServices.length;
            document.getElementById('selectedServiceCount').textContent = `${count}/${total}`;
        }

        // 수행용역 선택에 따른 그래프 하이라이팅
        function updateServiceHighlighting() {
            if (!g) return; // 그래프가 아직 초기화되지 않은 경우

            // 선택된 수행용역이 없으면 모든 노드를 정상 상태로
            if (selectedServices.size === 0) {
                g.selectAll('.node')
                    .classed('blurred', false)
                    .classed('highlighted', false)
                    .classed('service-selected', false);
                
                g.selectAll('.link')
                    .classed('blurred', false)
                    .classed('highlighted', false);
                    
                g.selectAll('.node-label')
                    .classed('service-highlighted', false);
                
                return;
            }

            // 선택된 수행용역과 관련된 노드들 찾기
            const selectedServiceNodes = new Set();
            const connectedContractNodes = new Set();
            const highlightedLinks = new Set();

            // 선택된 수행용역 노드들과 연결된 계약들 찾기
            nodes.forEach(node => {
                if (node.type === 'service' && selectedServices.has(node.id)) {
                    selectedServiceNodes.add(node.id);
                }
            });

            // 링크를 통해 연결된 계약들 찾기
            links.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                
                if (selectedServiceNodes.has(sourceId)) {
                    connectedContractNodes.add(targetId);
                    highlightedLinks.add(link);
                } else if (selectedServiceNodes.has(targetId)) {
                    connectedContractNodes.add(sourceId);
                    highlightedLinks.add(link);
                }
            });

            // 모든 관련 노드들을 합치기
            const allRelatedNodes = new Set([...selectedServiceNodes, ...connectedContractNodes]);

            // "선택만 보기" 모드 처리
            if (showSelectedOnly) {
                g.selectAll('.node')
                    .style('display', d => allRelatedNodes.has(d.id) ? null : 'none');
                
                g.selectAll('.link')
                    .style('display', d => highlightedLinks.has(d) ? null : 'none');
            } else {
                // 모든 노드를 다시 표시
                g.selectAll('.node')
                    .style('display', null);
                
                g.selectAll('.link')
                    .style('display', null);
                
                // 하이라이팅 적용
                g.selectAll('.node')
                    .classed('blurred', d => !allRelatedNodes.has(d.id))
                    .classed('highlighted', d => allRelatedNodes.has(d.id))
                    .classed('service-selected', d => selectedServiceNodes.has(d.id));
                
                g.selectAll('.link')
                    .classed('blurred', d => !highlightedLinks.has(d))
                    .classed('highlighted', d => highlightedLinks.has(d));
            }

            // 선택된 수행용역과 연결된 노드들의 라벨을 강조
            g.selectAll('.node-label')
                .classed('service-highlighted', d => allRelatedNodes.has(d.id));
                
            // 선택 해제 버튼 표시
            document.getElementById('clearSelection').classList.add('visible');
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EAN 계약 네트워크</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.4.2/dist/pixi.min.js"></script>
    <link rel="preload" href="styles.css?v=2024090701" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="styles.css?v=2024090701"></noscript>
    <style>
        /* 검색 하이라이트 스타일 */
        .node.search-match {
            stroke: #fbbf24 !important;
            stroke-width: 3px !important;
        }
        .node.search-dim {
            opacity: 0.3;
        }
        /* 노드 선택 스타일 */
        .node.highlighted {
            stroke: #ef4444 !important;
            stroke-width: 3px !important;
        }
        .node.blurred {
            opacity: 0.3;
        }
        .link.highlighted {
            stroke: #ef4444 !important;
            stroke-width: 3px !important;
        }
        .link.blurred {
            opacity: 0.2;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="graph-container">
            <!-- 로딩 화면 -->
            <div class="loading" id="loading">
                <div class="eco-spinner"></div>
                <div class="loading-text">
                    <span class="en-text">Connecting the network footprints of EAN</span><br>
                    <span class="en-sub-text">Architectural group in environmental, ecological, and energy fields</span><br>
                    <span class="en-wait">Please wait a moment</span><br><br>
                    <span class="ko-text">환경·생태·에너지 분야 건축인 그룹 EAN의</span><br>
                    <span class="ko-sub-text">네트워크 발자취를 연결하고 있습니다</span><br>
                    <span class="ko-wait">잠시만 기다려주세요</span>
                </div>
            </div>
            
            <!-- 플로팅 컨트롤 패널 -->
            <div class="floating-controls">
                <div class="control-group">
                    <label>검색</label>
                    <input type="text" class="search-input" id="searchInput" placeholder="계약명, 수행용역 검색..." style="width: 100%;">
                    <div class="zoom-controls-inline" style="justify-content: center; margin-top: 12px;">
                        <button class="zoom-btn" id="zoomIn">+</button>
                        <button class="zoom-btn" id="zoomOut">−</button>
                        <button class="zoom-btn" id="resetZoom">⌂</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>회사 연대기</label>
                    <div class="year-selector-container">
                        <div class="year-selector">
                            <div class="year-input-group">
                                <label for="startYear">시작:</label>
                                <select id="startYear" class="year-dropdown">
                                    <option value="2020">2020</option>
                                    <option value="2021">2021</option>
                                    <option value="2022">2022</option>
                                    <option value="2023">2023</option>
                                    <option value="2024">2024</option>
                                </select>
                            </div>
                            <div class="year-input-group">
                                <label for="endYear">끝:</label>
                                <select id="endYear" class="year-dropdown">
                                    <option value="2020">2020</option>
                                    <option value="2021">2021</option>
                                    <option value="2022">2022</option>
                                    <option value="2023">2023</option>
                                    <option value="2024" selected>2024</option>
                                </select>
                            </div>
                        </div>
                        <div class="timeline-display">
                            <div class="timeline-period">
                                <span class="period-label">EAN 여정</span>
                                <span class="period-range">
                                    <span id="timelineStart">2020</span>
                                    <span class="period-arrow">→</span>
                                    <span id="timelineEnd">2024</span>
                                </span>
                            </div>
                        </div>
                        
                        <div class="timeline-stats">
                            <div class="stat-item">
                                <span class="stat-label">총 노드:</span>
                                <span class="stat-value" id="totalNodes">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">연결:</span>
                                <span class="stat-value" id="totalLinks">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">표시된 노드:</span>
                                <span class="stat-value" id="visibleNodes">0</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="inline-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3b82f6;"></div>
                            <span>계약명</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #047857;"></div>
                            <span>수행용역</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 플로팅 오버레이 카드들 -->
            <div class="overlay-cards">
                <div class="overlay-card">
                    <h3>
                        수행용역
                        <span id="selectedServiceCount" style="font-size: 12px; color: #6b7280;">0/43</span>
                    </h3>
                    
                    <input type="text" class="service-search" id="serviceSearch" placeholder="수행용역 검색...">
                    
                    <div class="service-controls">
                        <button class="service-control-btn" id="selectAllServices">모두 선택</button>
                        <button class="service-control-btn" id="clearAllServices">모두 해제</button>
                        <button class="service-control-btn" id="showSelectedOnly">선택만 보기</button>
                    </div>
                    
                    <div class="service-list" id="serviceList">
                        <!-- 수행용역 리스트가 여기에 동적으로 생성됩니다 -->
                    </div>
                </div>
            </div>
            
            <button class="clear-selection" id="clearSelection">선택 해제</button>
            
            <div id="graph-container"></div>
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        // 전역 변수 (PIXI.js 기반)
        let allData = [];
        let filteredData = [];
        let nodes = [];
        let links = [];
        let simulation;
        let app, viewport;
        let nodeContainer, linkContainer;
        let width, height;
        let selectedNode = null;
        let currentScale = 1;
        let selectedServices = new Set();
        let allServices = [];
        let showSelectedOnly = false;
        let yearRange = { min: 2020, max: 2024 };
        let availableYears = [];
        let isSimulationRunning = false;
        
        // PIXI.js 관련 변수
        let nodeGraphics = new Map();
        let linkGraphics = new Map();
        
        // 성능 모니터링 변수
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        // 색상 스키마 (수행용역 더 진한 녹색)
        const colors = {
            contract: '#3b82f6',
            service: '#047857'  // 연결선보다 더 진한 녹색
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await loadData();
                initGraph();
                setupEventListeners();
                updateStats();
            } catch (error) {
                console.error('초기화 오류:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ef4444;">❌ 데이터 로딩 실패</div>
                    <div style="font-size: 12px; margin-top: 10px;">JSON 데이터 파일을 확인해주세요.</div>
                `;
            }
        });

        // 데이터 로드 (JSON 전용)
        async function loadData() {
            try {
                console.log('JSON 데이터 로드 중...');
                const startTime = performance.now();
                
                const response = await fetch('data.json');
                if (!response.ok) {
                    throw new Error(`HTTP 오류: ${response.status} - ${response.statusText}`);
                }
                
                const jsonData = await response.json();
                console.log('JSON 구조 확인:', Object.keys(jsonData));
                
                if (!jsonData.records || !jsonData.lookup) {
                    throw new Error('JSON 구조 오류: records 또는 lookup 누락');
                }
                
                console.log(`JSON 로드 완료: ${jsonData.records.length.toLocaleString()}개 레코드`);
                
                allData = jsonData.records.map((record, index) => {
                    if (!record || record.length < 3) {
                        console.warn(`잘못된 레코드 ${index}:`, record);
                        return null;
                    }
                    
                    const [yearIdx, contractIdx, serviceIdx] = record;
                    const year = jsonData.lookup.years[yearIdx];
                    const contract = jsonData.lookup.contracts[contractIdx];
                    const service = jsonData.lookup.services[serviceIdx];
                    
                    if (!year || !contract || !service) {
                        console.warn(`매핑 실패 ${index}:`, {
                            yearIdx, year,
                            contractIdx, contract, 
                            serviceIdx, service
                        });
                        return null;
                    }
                    
                    return { year, contract, service };
                }).filter(item => item !== null);
                
                const endTime = performance.now();
                console.log(`JSON 파싱 완료: ${allData.length.toLocaleString()}개 항목 (${(endTime - startTime).toFixed(1)}ms)`);
                
                if (allData.length === 0) {
                    throw new Error('데이터 매핑 결과가 비어있음');
                }
                
                // 데이터 처리 완료
                filteredData = [...allData];
                createNetworkData();
                initializeTimelineRuler();
                initializeServiceBrowser();
                
            } catch (error) {
                console.error('JSON 데이터 로드 실패:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ef4444;">❌ JSON 데이터 로드 실패</div>
                    <div style="font-size: 12px; margin-top: 10px; color: #6b7280;">
                        오류: ${error.message}<br>
                        브라우저 콘솔(F12)에서 상세 오류를 확인하세요.
                    </div>
                `;
                throw error;
            }
        }

        // 네트워크 데이터 생성 (무결성 검증 강화)
        function createNetworkData() {
            console.log('네트워크 데이터 생성 시작...', filteredData.length, '개 항목');
            
            const nodeMap = new Map();
            const linkMap = new Map();
            let processedCount = 0;
            let errorCount = 0;

            filteredData.forEach((d, index) => {
                // 데이터 무결성 검증
                if (!d || typeof d.contract === 'undefined' || typeof d.service === 'undefined') {
                    console.warn(`잘못된 데이터 항목 ${index}:`, d);
                    errorCount++;
                    return;
                }
                
                if (!d.contract || d.contract === '' || !d.service || d.service === '') {
                    console.warn(`비어있는 데이터 ${index}:`, d);
                    errorCount++;
                    return;
                }
                
                // 계약명 노드
                const contractId = String(d.contract).trim();
                if (!nodeMap.has(contractId)) {
                    nodeMap.set(contractId, {
                        id: contractId,
                        type: 'contract',
                        year: d.year,
                        connections: 0
                    });
                }

                // 수행용역 노드
                const serviceId = String(d.service).trim();
                if (!nodeMap.has(serviceId)) {
                    nodeMap.set(serviceId, {
                        id: serviceId,
                        type: 'service',
                        connections: 0
                    });
                }

                // 링크 생성
                const linkId = `${contractId}|${serviceId}`;
                if (!linkMap.has(linkId)) {
                    linkMap.set(linkId, {
                        source: contractId,
                        target: serviceId,
                        weight: 1
                    });
                    nodeMap.get(contractId).connections++;
                    nodeMap.get(serviceId).connections++;
                } else {
                    linkMap.get(linkId).weight++;
                }
                
                processedCount++;
            });

            nodes = Array.from(nodeMap.values());
            links = Array.from(linkMap.values());
            
            const contractNodes = nodes.filter(n => n.type === 'contract').length;
            const serviceNodes = nodes.filter(n => n.type === 'service').length;
            
            console.log(`네트워크 데이터 생성 완료:`, {
                totalRecords: filteredData.length,
                processed: processedCount,
                errors: errorCount,
                totalNodes: nodes.length,
                contractNodes: contractNodes,
                serviceNodes: serviceNodes,
                links: links.length,
                expectedNodes: `계약 ${contractNodes} + 서비스 ${serviceNodes} = ${contractNodes + serviceNodes}`
            });
            
            // 무결성 검증 결과 출력
            if (errorCount > 0) {
                console.warn(`데이터 무결성 문제: ${errorCount}개 항목에서 오류 발견`);
            }
        }

        // 그래프 초기화 (간소화)
        function initGraph() {
            console.log('PIXI.js WebGL 그래프 초기화...');
            
            const container = document.querySelector('.graph-container');
            width = container.clientWidth;
            height = container.clientHeight;

            // PIXI.js Application 생성 (WebGL 활성화)
            app = new PIXI.Application({
                width: width,
                height: height,
                backgroundColor: 0xf8fafc, // 배경색
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                powerPreference: 'high-performance' // GPU 성능 우선
            });

            // 컨테이너에 PIXI 캔버스 추가
            const graphContainer = document.getElementById('graph-container');
            graphContainer.appendChild(app.view);

            // 뷰포트 컨테이너 생성 (줌/팬용)
            viewport = new PIXI.Container();
            app.stage.addChild(viewport);

            // 렌더링 레이어 생성
            linkContainer = new PIXI.Container();
            nodeContainer = new PIXI.Container();
            viewport.addChild(linkContainer);
            viewport.addChild(nodeContainer);

            // 기본 줌/팬 설정
            setupInteractions();

            // 초기 줌 레벨 설정 (줌 아웃된 상태에서 시작)
            currentScale = 0.2;
            viewport.scale.set(currentScale);
            viewport.position.set(width * 1.95 * currentScale, height * 1.95 * currentScale);

            // D3.js force simulation 설정 (레이아웃 계산용)
            simulation = d3.forceSimulation()
                .force('link', d3.forceLink().id(d => d.id).distance(180).strength(0.4))
                .force('charge', d3.forceManyBody().strength(-800).distanceMax(1000))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => getNodeSize(d) + 10));

            renderGraph();
            
            // 성능 모니터링 시작
            startPerformanceMonitoring();
            
            console.log('PIXI.js WebGL 초기화 완료');
        }
        
        // 성능 모니터링 시작
        function startPerformanceMonitoring() {
            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - lastTime >= 1000) {
                    fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                    frameCount = 0;
                    lastTime = currentTime;
                    
                    // FPS를 UI에 표시
                    updatePerformanceStats();
                }
                
                requestAnimationFrame(updateFPS);
            }
            
            requestAnimationFrame(updateFPS);
        }
        
        // 성능 통계 업데이트
        function updatePerformanceStats() {
            // 콘솔에 성능 정보 출력
            console.log(`FPS: ${fps}, Nodes: ${nodes.length}, Links: ${links.length}, WebGL: ${app.renderer.type === 1 ? 'Yes' : 'No'}`);
            
            // 페이지에 성능 정보 표시 (개발자용)
            if (!document.getElementById('performance-stats')) {
                const perfDiv = document.createElement('div');
                perfDiv.id = 'performance-stats';
                perfDiv.style.position = 'fixed';
                perfDiv.style.top = '10px';
                perfDiv.style.left = '10px';
                perfDiv.style.background = 'rgba(0,0,0,0.8)';
                perfDiv.style.color = 'white';
                perfDiv.style.padding = '10px';
                perfDiv.style.borderRadius = '5px';
                perfDiv.style.fontFamily = 'monospace';
                perfDiv.style.fontSize = '12px';
                perfDiv.style.zIndex = '10000';
                document.body.appendChild(perfDiv);
            }
            
            const perfDiv = document.getElementById('performance-stats');
            perfDiv.innerHTML = `
                FPS: ${fps}<br>
                Nodes: ${nodes.length}<br>
                Links: ${links.length}<br>
                WebGL: ${app.renderer.type === 1 ? 'Yes' : 'No'}<br>
                Scale: ${currentScale.toFixed(2)}
            `;
        }

        // PIXI.js 인터랙션 설정
        function setupInteractions() {
            let isDragging = false;
            let dragStart = { x: 0, y: 0 };

            app.view.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragStart.x = e.clientX - viewport.position.x;
                dragStart.y = e.clientY - viewport.position.y;
            });

            app.view.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    viewport.position.x = e.clientX - dragStart.x;
                    viewport.position.y = e.clientY - dragStart.y;
                }
            });

            app.view.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // 휠 줌 지원
            app.view.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.1, Math.min(4, currentScale * scaleFactor));
                
                if (newScale !== currentScale) {
                    const worldPos = {
                        x: (e.clientX - viewport.position.x) / currentScale,
                        y: (e.clientY - viewport.position.y) / currentScale
                    };
                    
                    currentScale = newScale;
                    viewport.scale.set(currentScale);
                    
                    viewport.position.x = e.clientX - worldPos.x * currentScale;
                    viewport.position.y = e.clientY - worldPos.y * currentScale;
                }
            });
        }

        // PIXI.js 그래프 렌더링 (WebGL 기반)
        function renderGraph() {
            console.log('PIXI.js WebGL 렌더링 시작...', nodes.length, '개 노드,', links.length, '개 링크');
            
            if (!nodes || nodes.length === 0) {
                console.error('노드가 비어있음!');
                return;
            }
            
            // 기존 그래픽 요소 클리어
            linkContainer.removeChildren();
            nodeContainer.removeChildren();
            nodeGraphics.clear();
            linkGraphics.clear();

            // 색상 변환 함수
            function hexToPixiColor(hex) {
                return parseInt(hex.replace('#', '0x'));
            }

            // 링크 렌더링 (PIXI Graphics)
            console.log('링크 렌더링 중...');
            links.forEach((link, index) => {
                const linkGraphic = new PIXI.Graphics();
                linkGraphic.lineStyle(
                    link.weight ? Math.sqrt(link.weight) + 1 : 1, 
                    0x999999, 
                    0.4
                );
                linkGraphic.moveTo(0, 0).lineTo(100, 100); // 임시 위치, tick에서 업데이트
                linkContainer.addChild(linkGraphic);
                linkGraphics.set(index, linkGraphic);
            });

            // 노드 렌더링 (PIXI Graphics)
            console.log('노드 렌더링 중...');
            nodes.forEach((node, index) => {
                const nodeGraphic = new PIXI.Graphics();
                const radius = getNodeSize(node);
                const fillColor = hexToPixiColor(colors[node.type]);
                
                nodeGraphic.beginFill(fillColor);
                nodeGraphic.lineStyle(1.5, 0xffffff);
                nodeGraphic.drawCircle(0, 0, radius);
                nodeGraphic.endFill();
                
                // 인터랙티브 설정
                nodeGraphic.interactive = true;
                nodeGraphic.cursor = 'pointer';
                nodeGraphic.userData = node;
                
                // 이벤트 리스너
                nodeGraphic.on('pointerover', (event) => {
                    showTooltipPIXI(event, node);
                });
                nodeGraphic.on('pointerout', hideTooltip);
                nodeGraphic.on('pointerdown', (event) => {
                    event.stopPropagation();
                    selectNode(node);
                });
                
                // 드래그 이벤트 설정
                setupNodeDrag(nodeGraphic, node);
                
                nodeContainer.addChild(nodeGraphic);
                nodeGraphics.set(node.id, nodeGraphic);
            });

            // 텍스트 라벨 추가 (서비스 노드만)
            console.log('라벨 렌더링 중...');
            const serviceNodes = nodes.filter(d => d.type === 'service');
            serviceNodes.forEach(node => {
                const text = new PIXI.Text(truncateText(node.id, 15), {
                    fontSize: 10,
                    fill: 0x333333,
                    align: 'center'
                });
                text.anchor.set(0.5);
                text.userData = node;
                nodeContainer.addChild(text);
                
                // 라벨 그래픽 맵에 저장 (업데이트용)
                const labelKey = `label_${node.id}`;
                nodeGraphics.set(labelKey, text);
            });

            console.log('PIXI.js 렌더링 완료:', {
                linkElements: links.length,
                nodeElements: nodes.length, 
                labelElements: serviceNodes.length
            });

            // 배경 클릭 시 선택 해제
            app.view.addEventListener('click', (e) => {
                if (e.target === app.view) {
                    clearSelection();
                }
            });

            // D3.js 시뮬레이션 설정
            simulation.nodes(nodes);
            simulation.force('link').links(links);

            // PIXI.js tick 함수 (고성능)
            simulation.on('tick', () => {
                // 링크 위치 업데이트
                links.forEach((link, index) => {
                    const linkGraphic = linkGraphics.get(index);
                    if (linkGraphic) {
                        linkGraphic.clear();
                        linkGraphic.lineStyle(
                            link.weight ? Math.sqrt(link.weight) + 1 : 1, 
                            0x999999, 
                            0.4
                        );
                        linkGraphic.moveTo(link.source.x, link.source.y);
                        linkGraphic.lineTo(link.target.x, link.target.y);
                    }
                });

                // 노드 위치 업데이트
                nodes.forEach(node => {
                    const nodeGraphic = nodeGraphics.get(node.id);
                    if (nodeGraphic) {
                        nodeGraphic.position.set(node.x, node.y);
                    }
                    
                    // 라벨 위치 업데이트 (서비스 노드만)
                    if (node.type === 'service') {
                        const labelGraphic = nodeGraphics.get(`label_${node.id}`);
                        if (labelGraphic) {
                            labelGraphic.position.set(node.x, node.y + getNodeSize(node) + 12);
                        }
                    }
                });
            });

            // 시뮬레이션 시작
            simulation.alpha(1).restart();
            isSimulationRunning = true;
            console.log('PIXI.js WebGL 시뮬레이션 시작됨');
            
            // 로딩 화면 숨김
            document.getElementById('loading').style.display = 'none';
        }

        // PIXI.js 툴팁 표시
        function showTooltipPIXI(event, node) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <strong>${node.id}</strong><br>
                타입: ${node.type === 'contract' ? '계약' : '수행용역'}<br>
                연결: ${node.connections || 0}개
            `;
            tooltip.style.left = event.data.global.x + 10 + 'px';
            tooltip.style.top = event.data.global.y - 10 + 'px';
            tooltip.style.display = 'block';
        }

        // PIXI.js 노드 드래그 설정
        function setupNodeDrag(nodeGraphic, nodeData) {
            let isDragging = false;
            
            nodeGraphic.on('pointerdown', (event) => {
                isDragging = true;
                nodeGraphic.alpha = 0.8;
                if (!event.data.originalEvent.shiftKey) {
                    simulation.alphaTarget(0.3).restart();
                }
            });
            
            nodeGraphic.on('pointermove', (event) => {
                if (isDragging) {
                    const position = event.data.getLocalPosition(viewport);
                    nodeData.fx = position.x;
                    nodeData.fy = position.y;
                }
            });
            
            nodeGraphic.on('pointerup', () => {
                if (isDragging) {
                    isDragging = false;
                    nodeGraphic.alpha = 1.0;
                    if (!simulation.alphaTarget()) simulation.alphaTarget(0);
                    nodeData.fx = null;
                    nodeData.fy = null;
                }
            });
            
            nodeGraphic.on('pointerupoutside', () => {
                if (isDragging) {
                    isDragging = false;
                    nodeGraphic.alpha = 1.0;
                    if (!simulation.alphaTarget()) simulation.alphaTarget(0);
                    nodeData.fx = null;
                    nodeData.fy = null;
                }
            });
        }

        // 노드 크기 계산
        function getNodeSize(d) {
            return Math.max(8, Math.min(8 + Math.sqrt(d.connections) * 2, 25));
        }

        // 텍스트 자르기
        function truncateText(text, maxLength) {
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
        }

        // 네트워크 경계 계산
        function calculateNetworkBounds() {
            if (!nodes || nodes.length === 0) return null;
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            nodes.forEach(node => {
                if (node.x !== undefined && node.y !== undefined) {
                    minX = Math.min(minX, node.x);
                    maxX = Math.max(maxX, node.x);
                    minY = Math.min(minY, node.y);
                    maxY = Math.max(maxY, node.y);
                }
            });
            
            return {
                minX, maxX, minY, maxY,
                width: maxX - minX,
                height: maxY - minY,
                centerX: (minX + maxX) / 2,
                centerY: (minY + maxY) / 2
            };
        }

        // 전체 네트워크를 보기 위한 최적 줌 레벨 계산
        function getOptimalZoomTransform() {
            const bounds = calculateNetworkBounds();
            if (!bounds) return d3.zoomIdentity;
            
            // 여백을 고려한 스케일 계산 (화면의 80% 사용)
            const padding = 100;
            const scaleX = (width - padding * 2) / bounds.width;
            const scaleY = (height - padding * 2) / bounds.height;
            const scale = Math.min(scaleX, scaleY, 1); // 최대 1배까지만
            
            // 중앙 정렬을 위한 translate 계산
            const translateX = width / 2 - bounds.centerX * scale;
            const translateY = height / 2 - bounds.centerY * scale;
            
            return d3.zoomIdentity
                .translate(translateX, translateY)
                .scale(scale);
        }

        // 전체 보기로 리셋
        // 구 SVG resetToOptimalView() 함수는 resetToOptimalViewPIXI()로 교체됨

        // 기본 함수들
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const rect = document.querySelector('.graph-container').getBoundingClientRect();
            
            tooltip.innerHTML = `
                <strong>${d.id}</strong><br>
                타입: ${d.type === 'contract' ? '계약명' : '수행용역'}<br>
                연결: ${d.connections}개
                ${d.year ? `<br>연도: ${d.year}` : ''}
            `;
            
            tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
            tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function selectNode(targetNode) {
            selectedNode = targetNode;
            
            const connectedNodes = new Set([targetNode.id]);
            const connectedLinks = new Set();
            
            links.forEach(link => {
                if (link.source.id === targetNode.id || link.target.id === targetNode.id) {
                    connectedNodes.add(link.source.id);
                    connectedNodes.add(link.target.id);
                    connectedLinks.add(link);
                }
            });

            // PIXI.js 노드 하이라이트
            nodes.forEach(node => {
                const nodeGraphic = nodeGraphics.get(node.id);
                if (nodeGraphic) {
                    if (connectedNodes.has(node.id)) {
                        nodeGraphic.alpha = 1.0;
                        nodeGraphic.tint = 0xffffff;
                    } else {
                        nodeGraphic.alpha = 0.3;
                        nodeGraphic.tint = 0x888888;
                    }
                }
            });

            // PIXI.js 링크 하이라이트
            links.forEach((link, index) => {
                const linkGraphic = linkGraphics.get(index);
                if (linkGraphic) {
                    if (connectedLinks.has(link)) {
                        linkGraphic.alpha = 0.8;
                        linkGraphic.tint = 0xffffff;
                    } else {
                        linkGraphic.alpha = 0.1;
                        linkGraphic.tint = 0x888888;
                    }
                }
            });

            document.getElementById('clearSelection').classList.add('visible');
        }

        function clearSelection() {
            selectedNode = null;
            selectedServices.clear();
            showSelectedOnly = false;
            
            // PIXI.js 노드 상태 초기화
            nodes.forEach(node => {
                const nodeGraphic = nodeGraphics.get(node.id);
                if (nodeGraphic) {
                    nodeGraphic.alpha = 1.0;
                    nodeGraphic.tint = 0xffffff;
                    nodeGraphic.visible = true;
                }
            });

            // PIXI.js 링크 상태 초기화
            links.forEach((link, index) => {
                const linkGraphic = linkGraphics.get(index);
                if (linkGraphic) {
                    linkGraphic.alpha = 0.4;
                    linkGraphic.tint = 0xffffff;
                    linkGraphic.visible = true;
                }
            });

            document.getElementById('clearSelection').classList.remove('visible');
        }

        // 드래그 이벤트
        // SVG 드래그 함수들은 PIXI.js setupNodeDrag()로 이동됨

        // PIXI.js 이벤트 리스너 설정
        function setupEventListeners() {
            // PIXI.js 줌 컨트롤
            document.getElementById('zoomIn').addEventListener('click', () => {
                zoomInPIXI();
            });

            document.getElementById('zoomOut').addEventListener('click', () => {
                zoomOutPIXI();
            });

            document.getElementById('resetZoom').addEventListener('click', () => {
                resetToOptimalViewPIXI();
            });

            // 선택 해제 버튼
            document.getElementById('clearSelection').addEventListener('click', () => {
                clearSelection();
            });
            
            // PIXI.js 검색 기능
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                searchNodesPIXI(searchTerm);
            });
        }

        // PIXI.js 줌 인 함수
        function zoomInPIXI() {
            const scaleFactor = 1.2;
            const newScale = Math.min(4, currentScale * scaleFactor);
            if (newScale !== currentScale) {
                const centerX = width / 2;
                const centerY = height / 2;
                const worldPos = {
                    x: (centerX - viewport.position.x) / currentScale,
                    y: (centerY - viewport.position.y) / currentScale
                };
                
                currentScale = newScale;
                viewport.scale.set(currentScale);
                viewport.position.x = centerX - worldPos.x * currentScale;
                viewport.position.y = centerY - worldPos.y * currentScale;
            }
        }

        // PIXI.js 줌 아웃 함수
        function zoomOutPIXI() {
            const scaleFactor = 0.8;
            const newScale = Math.max(0.1, currentScale * scaleFactor);
            if (newScale !== currentScale) {
                const centerX = width / 2;
                const centerY = height / 2;
                const worldPos = {
                    x: (centerX - viewport.position.x) / currentScale,
                    y: (centerY - viewport.position.y) / currentScale
                };
                
                currentScale = newScale;
                viewport.scale.set(currentScale);
                viewport.position.x = centerX - worldPos.x * currentScale;
                viewport.position.y = centerY - worldPos.y * currentScale;
            }
        }

        // PIXI.js 최적 뷰 리셋 함수
        function resetToOptimalViewPIXI() {
            // 네트워크 경계 계산
            const bounds = calculateNetworkBounds();
            const padding = 50;
            const scaleX = (width - padding * 2) / bounds.width;
            const scaleY = (height - padding * 2) / bounds.height;
            const optimalScale = Math.min(scaleX, scaleY, 1); // 최대 1배까지
            
            currentScale = optimalScale;
            viewport.scale.set(currentScale);
            
            // 중앙 정렬
            const centerX = bounds.centerX * currentScale;
            const centerY = bounds.centerY * currentScale;
            viewport.position.x = width / 2 - centerX;
            viewport.position.y = height / 2 - centerY;
        }

        // PIXI.js 노드 검색 함수
        function searchNodesPIXI(searchTerm) {
            if (searchTerm === '') {
                // 검색어가 비어있으면 모든 노드를 기본 상태로
                nodes.forEach(node => {
                    const nodeGraphic = nodeGraphics.get(node.id);
                    if (nodeGraphic) {
                        nodeGraphic.alpha = 1.0;
                        nodeGraphic.tint = 0xffffff; // 기본 색상
                    }
                });
            } else {
                // 검색 결과 하이라이트
                nodes.forEach(node => {
                    const nodeGraphic = nodeGraphics.get(node.id);
                    if (nodeGraphic) {
                        if (node.id.toLowerCase().includes(searchTerm)) {
                            // 매치되는 노드: 하이라이트
                            nodeGraphic.alpha = 1.0;
                            nodeGraphic.tint = 0xfbbf24; // 노란색 하이라이트
                        } else {
                            // 매치되지 않는 노드: 흐리게
                            nodeGraphic.alpha = 0.3;
                            nodeGraphic.tint = 0xffffff;
                        }
                    }
                });
            }
        }
        

        // PIXI.js 통계 업데이트
        function updateStats() {
            let visibleNodeCount = 0;
            nodes.forEach(node => {
                const nodeGraphic = nodeGraphics.get(node.id);
                if (nodeGraphic && nodeGraphic.visible) {
                    visibleNodeCount++;
                }
            });
            
            document.getElementById('totalNodes').textContent = nodes.length.toLocaleString();
            document.getElementById('totalLinks').textContent = links.length.toLocaleString();
            document.getElementById('visibleNodes').textContent = visibleNodeCount.toLocaleString();
        }

        // 타임라인 룰러 초기화
        function initializeTimelineRuler() {
            console.log('타임라인 초기화...');
            
            // 사용 가능한 연도 추출
            availableYears = [...new Set(allData.map(d => d.year))].sort();
            if (availableYears.length === 0) return;
            
            const startYear = Math.min(...availableYears);
            const endYear = Math.max(...availableYears);
            
            yearRange.min = startYear;
            yearRange.max = endYear;
            
            // 드롭다운 옵션 생성
            const startYearSelect = document.getElementById('startYear');
            const endYearSelect = document.getElementById('endYear');
            
            // 기존 옵션 제거
            startYearSelect.innerHTML = '';
            endYearSelect.innerHTML = '';
            
            // 사용 가능한 연도로 옵션 생성
            availableYears.forEach(year => {
                const startOption = document.createElement('option');
                startOption.value = year;
                startOption.textContent = year;
                if (year === startYear) startOption.selected = true;
                startYearSelect.appendChild(startOption);
                
                const endOption = document.createElement('option');
                endOption.value = year;
                endOption.textContent = year;
                if (year === endYear) endOption.selected = true;
                endYearSelect.appendChild(endOption);
            });
            
            // 드롭다운 이벤트 리스너 추가
            startYearSelect.addEventListener('change', (e) => {
                yearRange.min = parseInt(e.target.value);
                updateTimelineDisplay();
                filterDataByYear();
            });
            
            endYearSelect.addEventListener('change', (e) => {
                yearRange.max = parseInt(e.target.value);
                updateTimelineDisplay();
                filterDataByYear();
            });
            
            updateTimelineDisplay();
        }
        
        // 년도 필터링 함수
        function filterDataByYear() {
            // 년도 범위에 따라 데이터 필터링
            filteredData = allData.filter(d => d.year >= yearRange.min && d.year <= yearRange.max);
            createNetworkData();
            renderGraph();
            updateStats();
        }
        
        // 타임라인 디스플레이 업데이트
        function updateTimelineDisplay() {
            document.getElementById('timelineStart').textContent = yearRange.min;
            document.getElementById('timelineEnd').textContent = yearRange.max;
        }

        // 서비스 브라우저 초기화
        function initializeServiceBrowser() {
            console.log('서비스 브라우저 초기화...');
            
            // 모든 서비스 추출
            allServices = [...new Set(allData.map(d => d.service))].sort();
            
            if (allServices.length === 0) {
                console.warn('서비스가 없습니다');
                return;
            }
            
            console.log(`서비스 ${allServices.length}개 발견`);
            
            const serviceList = document.getElementById('serviceList');
            serviceList.innerHTML = '';
            
            allServices.forEach(service => {
                const serviceItem = document.createElement('div');
                serviceItem.className = 'service-item';
                serviceItem.innerHTML = `
                    <label class="service-label">
                        <input type="checkbox" class="service-checkbox" value="${service}">
                        <span class="service-name">${service}</span>
                    </label>
                `;
                serviceList.appendChild(serviceItem);
            });
            
            // 서비스 선택 이벤트 리스너
            serviceList.addEventListener('change', (e) => {
                if (e.target.classList.contains('service-checkbox')) {
                    const service = e.target.value;
                    if (e.target.checked) {
                        selectedServices.add(service);
                    } else {
                        selectedServices.delete(service);
                    }
                    updateServiceSelection();
                }
            });
            
            // 서비스 검색
            const serviceSearch = document.getElementById('serviceSearch');
            serviceSearch.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const serviceItems = serviceList.querySelectorAll('.service-item');
                
                serviceItems.forEach(item => {
                    const serviceName = item.querySelector('.service-name').textContent.toLowerCase();
                    item.style.display = serviceName.includes(searchTerm) ? 'block' : 'none';
                });
            });
            
            // 서비스 컨트롤 버튼
            document.getElementById('selectAllServices').addEventListener('click', () => {
                allServices.forEach(service => selectedServices.add(service));
                updateServiceCheckboxes();
                updateServiceSelection();
            });
            
            document.getElementById('clearAllServices').addEventListener('click', () => {
                selectedServices.clear();
                updateServiceCheckboxes();
                updateServiceSelection();
            });
            
            document.getElementById('showSelectedOnly').addEventListener('click', () => {
                showSelectedOnly = !showSelectedOnly;
                document.getElementById('showSelectedOnly').textContent = 
                    showSelectedOnly ? '전체 보기' : '선택만 보기';
                updateServiceSelection();
            });
            
            updateServiceCount();
        }
        
        // 서비스 체크박스 업데이트
        function updateServiceCheckboxes() {
            const checkboxes = document.querySelectorAll('.service-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectedServices.has(checkbox.value);
            });
        }
        
        // PIXI.js 서비스 선택 업데이트
        function updateServiceSelection() {
            if (selectedServices.size === 0 && !showSelectedOnly) {
                // 모든 노드와 링크 표시
                nodes.forEach(node => {
                    const nodeGraphic = nodeGraphics.get(node.id);
                    if (nodeGraphic) {
                        nodeGraphic.visible = true;
                    }
                });
                
                links.forEach((link, index) => {
                    const linkGraphic = linkGraphics.get(index);
                    if (linkGraphic) {
                        linkGraphic.visible = true;
                    }
                });
            } else {
                // 선택된 서비스와 관련된 노드만 표시
                const visibleServiceNodes = new Set();
                const visibleContractNodes = new Set();
                const visibleLinks = new Set();
                
                // 선택된 서비스와 연결된 계약 찾기
                links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    if (selectedServices.has(targetId)) {
                        visibleServiceNodes.add(targetId);
                        visibleContractNodes.add(sourceId);
                        visibleLinks.add(link);
                    }
                });
                
                // PIXI.js 노드 가시성 업데이트
                nodes.forEach(node => {
                    const nodeGraphic = nodeGraphics.get(node.id);
                    if (nodeGraphic) {
                        if (node.type === 'service') {
                            nodeGraphic.visible = visibleServiceNodes.has(node.id);
                        } else {
                            nodeGraphic.visible = visibleContractNodes.has(node.id);
                        }
                    }
                });
                
                // PIXI.js 링크 가시성 업데이트
                links.forEach((link, index) => {
                    const linkGraphic = linkGraphics.get(index);
                    if (linkGraphic) {
                        linkGraphic.visible = visibleLinks.has(link);
                    }
                });
            }
            
            updateServiceCount();
            updateStats(); // 가시성 변경 후 통계 업데이트
        }
        
        // 서비스 카운트 업데이트
        function updateServiceCount() {
            const selectedCount = selectedServices.size;
            const totalCount = allServices.length;
            document.getElementById('selectedServiceCount').textContent = `${selectedCount}/${totalCount}`;
        }
    </script>
</body>
</html>
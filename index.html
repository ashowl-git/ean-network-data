<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EAN 계약 네트워크</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="styles.css"></noscript>
</head>
<body>
    <div class="container">
        <div class="graph-container">
            <!-- 로딩 화면 -->
            <div class="loading" id="loading">
                <div class="eco-spinner"></div>
                <div class="loading-text">
                    <span class="en-text">Connecting the network footprints of EAN</span><br>
                    <span class="en-sub-text">Architectural group in environmental, ecological, and energy fields</span><br>
                    <span class="en-wait">Please wait a moment</span><br><br>
                    <span class="ko-text">환경·생태·에너지 분야 건축인 그룹 EAN의</span><br>
                    <span class="ko-sub-text">네트워크 발자취를 연결하고 있습니다</span><br>
                    <span class="ko-wait">잠시만 기다려주세요</span>
                </div>
            </div>
            
            <!-- 플로팅 컨트롤 패널 -->
            <div class="floating-controls">
                <div class="control-group">
                    <label>검색</label>
                    <div style="display: flex; gap: 8px; align-items: flex-end;">
                        <input type="text" class="search-input" id="searchInput" placeholder="계약명, 수행용역 검색..." style="flex: 1;">
                        <div class="zoom-controls-inline">
                            <button class="zoom-btn" id="zoomIn">+</button>
                            <button class="zoom-btn" id="zoomOut">−</button>
                            <button class="zoom-btn" id="resetZoom">⌂</button>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>회사 연대기</label>
                    <div class="timeline-ruler-container">
                        <div class="timeline-ruler">
                            <div class="ruler-track"></div>
                            <div class="ruler-ticks"></div>
                            <div class="ruler-labels"></div>
                            <div class="selection-range">
                                <div class="range-handle range-start" data-year="2020"></div>
                                <div class="range-handle range-end" data-year="2024"></div>
                                <div class="range-fill"></div>
                            </div>
                        </div>
                        <div class="timeline-display">
                            <div class="timeline-period">
                                <span class="period-label">EAN 여정</span>
                                <span class="period-range">
                                    <span id="timelineStart">2020</span>
                                    <span class="period-arrow">→</span>
                                    <span id="timelineEnd">2024</span>
                                </span>
                            </div>
                        </div>
                        
                        <div class="timeline-stats">
                            <div class="stat-item">
                                <span class="stat-label">총 노드:</span>
                                <span class="stat-value" id="totalNodes">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">연결:</span>
                                <span class="stat-value" id="totalLinks">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">표시된 노드:</span>
                                <span class="stat-value" id="visibleNodes">0</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>노드 타입</label>
                    <div class="filter-buttons" id="nodeTypeFilters">
                        <button class="filter-btn active" data-type="all">전체</button>
                        <button class="filter-btn" data-type="contract-only">계약명만</button>
                        <button class="filter-btn" data-type="service-only">수행용역만</button>
                    </div>
                    
                    <div class="inline-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3b82f6;"></div>
                            <span>계약명</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #047857;"></div>
                            <span>수행용역</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 플로팅 오버레이 카드들 -->
            <div class="overlay-cards">
                <div class="overlay-card">
                    <h3>
                        수행용역
                        <span id="selectedServiceCount" style="font-size: 12px; color: #6b7280;">0/43</span>
                    </h3>
                    
                    <input type="text" class="service-search" id="serviceSearch" placeholder="수행용역 검색...">
                    
                    <div class="service-controls">
                        <button class="service-control-btn" id="selectAllServices">모두 선택</button>
                        <button class="service-control-btn" id="clearAllServices">모두 해제</button>
                        <button class="service-control-btn" id="showSelectedOnly">선택만 보기</button>
                    </div>
                    
                    <div class="service-list" id="serviceList">
                        <!-- 수행용역 리스트가 여기에 동적으로 생성됩니다 -->
                    </div>
                </div>
            </div>
            
            <button class="clear-selection" id="clearSelection">선택 해제</button>
            
            <svg id="graph"></svg>
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        // 전역 변수
        let allData = [];
        let filteredData = [];
        let nodes = [];
        let links = [];
        let simulation;
        let svg, g;
        let width, height;
        let zoom;
        let selectedNode = null;
        let currentScale = 1;
        let selectedServices = new Set();
        let allServices = [];
        let showSelectedOnly = false;
        let yearRange = { min: 2020, max: 2024 };
        let availableYears = [];

        // 성능 최적화 변수
        let isSimulationRunning = false;
        let animationFrameId = null;
        let lastUpdateTime = 0;
        let visibleNodes = [];
        let visibleLinks = [];
        let nodeQuadTree = null;
        let performanceMode = false;
        let smartPerformanceMode = false;
        let viewport = { x: 0, y: 0, width: 0, height: 0, scale: 1 };
        let nodePool = [];
        let linkPool = [];
        let lastZoomTime = 0;
        let isZooming = false;

        // 색상 스키마 - 수행용역 노드를 더 진한 녹색으로 수정
        const colors = {
            contract: '#3b82f6',
            service: '#047857'  // 연결선보다 더 진한 녹색
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await loadData();
                initGraph();
                setupEventListeners();
                updateStats();
            } catch (error) {
                console.error('초기화 오류:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ef4444;">❌ 데이터 로딩 실패</div>
                    <div style="font-size: 12px; margin-top: 10px;">CSV 파일을 확인해주세요.</div>
                `;
            }
        });

        // 데이터 로드
        async function loadData() {
            try {
                console.log('JSON 데이터 로드 중...');
                const startTime = performance.now();
                
                const response = await fetch('data.json');
                const jsonData = await response.json();
                
                console.log(`JSON 로드 완료: ${jsonData.records.length.toLocaleString()}개 레코드`);
                
                allData = jsonData.records.map(record => ({
                    year: jsonData.lookup.years[record[0]],
                    contract: jsonData.lookup.contracts[record[1]], 
                    service: jsonData.lookup.services[record[2]]
                }));
                
                const endTime = performance.now();
                console.log(`JSON 파싱 완료: ${allData.length.toLocaleString()}개 항목 (${(endTime - startTime).toFixed(1)}ms)`);
                
            } catch (error) {
                console.warn('JSON 로드 실패, CSV로 폴백:', error);
                await loadDataCSV();
            }

            filteredData = [...allData];
            createNetworkData();
            initializeTimelineRuler();
            initializeServiceBrowser();
        }

        // CSV 폴백 함수
        async function loadDataCSV() {
            console.log('CSV 데이터 로드 중...');
            const startTime = performance.now();
            
            const response = await fetch('202508_EAN계약현황_완전본.csv');
            const text = await response.text();
            
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',');
            
            allData = lines.slice(1).map(line => {
                const values = parseCSVLine(line);
                return {
                    year: values[0]?.trim() || '',
                    contract: values[1]?.trim() || '',
                    service: values[2]?.trim() || ''
                };
            }).filter(d => d.year && d.contract && d.service);

            const endTime = performance.now();
            console.log(`CSV 파싱 완료: ${allData.length.toLocaleString()}개 항목 (${(endTime - startTime).toFixed(1)}ms)`);
        }

        // CSV 라인 파싱
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            
            return result;
        }

        // 네트워크 데이터 생성
        function createNetworkData() {
            const nodeMap = new Map();
            const linkMap = new Map();

            filteredData.forEach(d => {
                // 계약명 노드
                if (!nodeMap.has(d.contract)) {
                    nodeMap.set(d.contract, {
                        id: d.contract,
                        type: 'contract',
                        year: d.year,
                        connections: 0
                    });
                }

                // 수행용역 노드
                if (!nodeMap.has(d.service)) {
                    nodeMap.set(d.service, {
                        id: d.service,
                        type: 'service',
                        connections: 0
                    });
                }

                // 링크 생성
                const linkId = d.contract < d.service ? `${d.contract}|${d.service}` : `${d.service}|${d.contract}`;
                if (!linkMap.has(linkId)) {
                    linkMap.set(linkId, {
                        source: d.contract,
                        target: d.service,
                        weight: 1
                    });
                    nodeMap.get(d.contract).connections++;
                    nodeMap.get(d.service).connections++;
                } else {
                    linkMap.get(linkId).weight++;
                }
            });

            nodes = Array.from(nodeMap.values());
            links = Array.from(linkMap.values());
        }

        // 타임라인 룰러 초기화
        function initializeTimelineRuler() {
            const years = [...new Set(allData.map(d => parseInt(d.year)))].filter(y => !isNaN(y)).sort((a, b) => a - b);
            availableYears = years;
            
            if (years.length === 0) return;
            
            const minYear = Math.min(...years);
            const maxYear = Math.max(...years);
            
            yearRange.min = minYear;
            yearRange.max = maxYear;
            
            setTimeout(() => renderTimelineRuler(minYear, maxYear), 100);
            updateTimelineDisplay();
        }

        function renderTimelineRuler(minYear, maxYear) {
            const ticksContainer = document.querySelector('.ruler-ticks');
            const labelsContainer = document.querySelector('.ruler-labels');
            
            if (!ticksContainer || !labelsContainer) return;
            
            ticksContainer.innerHTML = '';
            labelsContainer.innerHTML = '';
            
            const totalYears = maxYear - minYear;
            const majorYears = [minYear];
            const yearStep = Math.max(1, Math.floor(totalYears / 4));
            
            for (let i = 1; i < 4; i++) {
                const year = minYear + (yearStep * i);
                if (year < maxYear) majorYears.push(year);
            }
            if (maxYear !== minYear) majorYears.push(maxYear);
            
            majorYears.forEach(year => {
                const position = totalYears === 0 ? 50 : ((year - minYear) / totalYears) * 100;
                
                const tick = document.createElement('div');
                tick.className = 'ruler-tick major';
                tick.style.left = `${position}%`;
                ticksContainer.appendChild(tick);
            });
            
            updateRangeSelection(minYear, maxYear, minYear, maxYear);
        }

        function updateRangeSelection(minYear, maxYear, startYear, endYear) {
            const totalYears = maxYear - minYear;
            const startPos = totalYears === 0 ? 0 : ((startYear - minYear) / totalYears) * 100;
            const endPos = totalYears === 0 ? 100 : ((endYear - minYear) / totalYears) * 100;
            
            const startHandle = document.querySelector('.range-start');
            const endHandle = document.querySelector('.range-end');
            const rangeFill = document.querySelector('.range-fill');
            const labelsContainer = document.querySelector('.ruler-labels');
            
            if (startHandle && endHandle && rangeFill) {
                startHandle.style.left = `${startPos}%`;
                endHandle.style.left = `${endPos}%`;
                startHandle.dataset.year = startYear;
                endHandle.dataset.year = endYear;
                
                rangeFill.style.left = `${startPos}%`;
                rangeFill.style.width = `${Math.max(1, endPos - startPos)}%`;
            }
            
            if (labelsContainer) {
                labelsContainer.innerHTML = '';
                
                const startLabel = document.createElement('div');
                startLabel.className = 'ruler-year selected';
                startLabel.textContent = startYear;
                startLabel.style.left = `${startPos}%`;
                startLabel.dataset.year = startYear;
                labelsContainer.appendChild(startLabel);
                
                if (startYear !== endYear) {
                    const endLabel = document.createElement('div');
                    endLabel.className = 'ruler-year selected';
                    endLabel.textContent = endYear;
                    endLabel.style.left = `${endPos}%`;
                    endLabel.dataset.year = endYear;
                    labelsContainer.appendChild(endLabel);
                }
            }
        }

        function updateTimelineDisplay() {
            const startEl = document.getElementById('timelineStart');
            const endEl = document.getElementById('timelineEnd');
            if (startEl) startEl.textContent = yearRange.min;
            if (endEl) endEl.textContent = yearRange.max;
        }

        // 그래프 초기화
        function initGraph() {
            const STARFIELD = {
                chargeStrength: -1500,
                distanceMin: 60,
                distanceMax: 2000,
                linkDistance: 180,
                linkStrength: 0.4,
                collidePadding: 24,
                collideStrength: 1.0,
                centerStrength: 0.03,
                axisStrength: 0.004,
                alphaDecay: 0.02,
                velocityDecay: 0.38
            };

            const container = document.querySelector('.graph-container');
            width = container.clientWidth;
            height = container.clientHeight;

            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);

            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('start', () => {
                    isZooming = true;
                    lastZoomTime = performance.now();
                })
                .on('zoom', throttleZoom((event) => {
                    // GPU 가속을 위한 transform3d 사용
                    const transform = event.transform;
                    g.style('transform', `translate3d(${transform.x}px, ${transform.y}px, 0) scale(${transform.k})`);
                    currentScale = transform.k;
                    
                    // 뷰포트 업데이트
                    updateViewport(transform);
                    
                    const nodeCount = nodes.length;
                    smartPerformanceMode = nodeCount > 2000;
                    performanceMode = nodeCount > 1000 || currentScale < 0.3;
                    
                    // 뷰포트 기반 렌더링
                    updateViewportRendering();
                }, 8))
                .on('end', () => {
                    isZooming = false;
                    // 줌 종료 후 품질 복원
                    setTimeout(() => {
                        if (!isZooming) {
                            updateLabelsVisibility();
                            updateNodeVisibility();
                        }
                    }, 100);
                });

            svg.call(zoom);
            g = svg.append('g');

            const nodeCount = nodes.length;
            smartPerformanceMode = nodeCount > 2000;
            performanceMode = nodeCount > 1000;
            
            // 노드 반지름 미리 캐시
            nodes.forEach(d => { 
                d._r = getNodeSize(d);
            });

            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(STARFIELD.linkDistance)
                    .strength(STARFIELD.linkStrength)
                )
                .force('charge', d3.forceManyBody()
                    .strength(STARFIELD.chargeStrength)
                    .distanceMin(STARFIELD.distanceMin)
                    .distanceMax(STARFIELD.distanceMax)
                )
                .force('center', d3.forceCenter(width / 2, height / 2).strength(STARFIELD.centerStrength))
                .force('collision', d3.forceCollide().radius(d => (d._r || getNodeSize(d)) + STARFIELD.collidePadding)
                    .strength(STARFIELD.collideStrength)
                )
                .force('x', d3.forceX(width / 2).strength(STARFIELD.axisStrength))
                .force('y', d3.forceY(height / 2).strength(STARFIELD.axisStrength))
                .alphaDecay(STARFIELD.alphaDecay)
                .alphaMin(0.001)
                .velocityDecay(STARFIELD.velocityDecay);

            renderGraph();
            document.getElementById('loading').style.display = 'none';
        }

        // 그래프 렌더링
        function renderGraph() {
            g.selectAll('*').remove();

            const nodeCount = nodes.length;
            smartPerformanceMode = nodeCount > 2000;
            performanceMode = nodeCount > 1000;
            
            // 링크 그리기
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke-width', d => {
                    if (smartPerformanceMode) {
                        return Math.min(Math.sqrt(d.weight) * 1.0 + 1, 3);
                    } else if (performanceMode) {
                        return Math.min(Math.sqrt(d.weight) * 1.2 + 1, 4.5);
                    } else {
                        return Math.min(Math.sqrt(d.weight) * 1.3 + 1.5, 6);
                    }
                })
                .style('opacity', smartPerformanceMode ? 0.5 : 0.4)
                .style('display', smartPerformanceMode && currentScale < 0.1 ? 'none' : null);

            // 노드 그리기
            const node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => getNodeSize(d))
                .attr('fill', d => colors[d.type])
                .style('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('mouseover', (event, d) => {
                    g.selectAll('.node-label')
                      .filter(l => l.id === d.id)
                      .classed('visible', true)
                      .classed('hovered', true);
                    showTooltip(event, d);
                })
                .on('mouseout', (event, d) => {
                    g.selectAll('.node-label')
                      .filter(l => l.id === d.id)
                      .classed('hovered', false)
                      .classed('visible', l => l.type === 'service');
                    hideTooltip();
                })
                .on('click', (event, d) => {
                    event.stopPropagation();
                    selectNode(d);
                });

            // 라벨 추가
            const label = g.append('g')
                .selectAll('text')
                .data(nodes.filter(d => d.type === 'service'))
                .enter().append('text')
                .attr('class', 'node-label')
                .attr('dy', d => getNodeSize(d) + 18)
                .text(d => {
                    const maxLength = smartPerformanceMode ? 15 : (performanceMode ? 20 : 25);
                    return truncateText(d.id, maxLength);
                })
                .classed('visible', d => d.type === 'service')
                .style('display', smartPerformanceMode && currentScale < 0.2 ? 'none' : null);

            // 배경 클릭 시 선택 해제
            svg.on('click', () => {
                clearSelection();
            });

            // 시뮬레이션 업데이트
            simulation.nodes(nodes);
            simulation.force('link').links(links);

            simulation.on('tick', () => {
                const now = Date.now();
                if (now - lastUpdateTime < 16) return;
                lastUpdateTime = now;

                updateVisibleElements();

                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            isSimulationRunning = true;
            simulation.alpha(performanceMode ? 0.8 : 1).restart();
            
            if (performanceMode) {
                setTimeout(() => {
                    if (simulation.alpha() < 0.1) {
                        simulation.stop();
                        isSimulationRunning = false;
                    }
                }, 3000);
            }

            updateNodeVisibility();
            updateLabelsVisibility();
        }

        // 노드 크기 계산
        function getNodeSize(d) {
            let baseSize, maxSize, connectionFactor;
            
            if (smartPerformanceMode && nodes.length > 1000) {
                baseSize = 4;
                maxSize = 18;
                connectionFactor = Math.sqrt(d.connections) * 1.2;
            } else if (performanceMode) {
                baseSize = 7;
                maxSize = 28;
                connectionFactor = Math.sqrt(d.connections) * 1.5;
            } else {
                baseSize = 8;
                maxSize = 35;
                connectionFactor = Math.sqrt(d.connections) * 1.8;
            }
            
            return Math.max(baseSize, Math.min(baseSize + connectionFactor, maxSize));
        }

        // 노드 선택 및 블러 효과
        function selectNode(targetNode) {
            selectedNode = targetNode;
            
            const connectedNodes = new Set([targetNode.id]);
            const connectedLinks = new Set();
            
            links.forEach(link => {
                if (link.source.id === targetNode.id || link.target.id === targetNode.id) {
                    connectedNodes.add(link.source.id);
                    connectedNodes.add(link.target.id);
                    connectedLinks.add(link);
                }
            });

            g.selectAll('.node')
                .classed('blurred', d => !connectedNodes.has(d.id))
                .classed('highlighted', d => connectedNodes.has(d.id));

            g.selectAll('.link')
                .classed('blurred', d => !connectedLinks.has(d))
                .classed('highlighted', d => connectedLinks.has(d));

            document.getElementById('clearSelection').classList.add('visible');
        }

        // 선택 해제
        function clearSelection() {
            selectedNode = null;
            
            selectedServices.clear();
            showSelectedOnly = false;
            document.getElementById('showSelectedOnly').classList.remove('active');
            document.getElementById('showSelectedOnly').textContent = '선택만 보기';
            
            g.selectAll('.node')
                .classed('blurred', false)
                .classed('highlighted', false)
                .classed('service-selected', false)
                .style('display', null);

            g.selectAll('.link')
                .classed('blurred', false)
                .classed('highlighted', false)
                .style('display', null);
                
            g.selectAll('.node-label')
                .classed('service-highlighted', false);

            document.getElementById('clearSelection').classList.remove('visible');
            
            updateServiceCount();
            renderServiceList();
        }

        // 성능 최적화 헬퍼 함수
        function throttle(func, delay) {
            let timeoutId;
            let lastExecTime = 0;
            return function (...args) {
                const currentTime = Date.now();
                
                if (currentTime - lastExecTime > delay) {
                    func.apply(this, args);
                    lastExecTime = currentTime;
                } else {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                        lastExecTime = Date.now();
                    }, delay);
                }
            };
        }
        
        // 줌 전용 고성능 스로틀링 (8ms)
        function throttleZoom(func, delay) {
            let rafId;
            let lastExecTime = 0;
            return function (...args) {
                const currentTime = performance.now();
                
                if (currentTime - lastExecTime > delay) {
                    func.apply(this, args);
                    lastExecTime = currentTime;
                } else {
                    cancelAnimationFrame(rafId);
                    rafId = requestAnimationFrame(() => {
                        func.apply(this, args);
                        lastExecTime = performance.now();
                    });
                }
            };
        }
        
        // 뷰포트 업데이트
        function updateViewport(transform) {
            viewport.x = -transform.x / transform.k;
            viewport.y = -transform.y / transform.k;
            viewport.width = width / transform.k;
            viewport.height = height / transform.k;
            viewport.scale = transform.k;
        }
        
        // 뷰포트 기반 렌더링 최적화
        function updateViewportRendering() {
            if (!g || nodes.length === 0) return;
            
            const buffer = Math.max(100, 300 / viewport.scale); // 동적 버퍼
            const viewBounds = {
                left: viewport.x - buffer,
                right: viewport.x + viewport.width + buffer,
                top: viewport.y - buffer,
                bottom: viewport.y + viewport.height + buffer
            };
            
            // 뷰포트 내 노드만 표시
            g.selectAll('.node').style('display', d => {
                if (!d.x || !d.y) return 'none';
                const inViewport = d.x >= viewBounds.left && 
                                  d.x <= viewBounds.right && 
                                  d.y >= viewBounds.top && 
                                  d.y <= viewBounds.bottom;
                return inViewport ? null : 'none';
            });
            
            // 줌 레벨에 따른 링크 표시 조정
            if (viewport.scale < 0.2 && links.length > 2000) {
                g.selectAll('.link').style('display', 'none');
            } else if (viewport.scale < 0.5 && links.length > 5000) {
                // 중요 링크만 표시 (가중치 높은 것)
                g.selectAll('.link').style('display', d => d.weight > 2 ? null : 'none');
            } else {
                g.selectAll('.link').style('display', null);
            }
            
            // 라벨 표시 최적화
            const showLabels = viewport.scale > 0.3;
            g.selectAll('.node-label').style('display', showLabels ? null : 'none');
        }

        // 뷰포트 내 요소만 업데이트
        function updateVisibleElements() {
            if (!g) return;
            
            const transform = d3.zoomTransform(svg.node());
            const viewBox = {
                x: -transform.x / transform.k,
                y: -transform.y / transform.k,
                width: width / transform.k,
                height: height / transform.k
            };

            if (performanceMode) {
                visibleNodes = nodes.filter(d => 
                    d.x >= viewBox.x - 50 && 
                    d.x <= viewBox.x + viewBox.width + 50 &&
                    d.y >= viewBox.y - 50 && 
                    d.y <= viewBox.y + viewBox.height + 50
                );
            } else {
                visibleNodes = nodes;
            }
        }

        // 노드 가시성 업데이트
        function updateNodeVisibility() {
            if (!g) return;

            const nodeSelection = g.selectAll('.node');
            nodeSelection.style('opacity', d => d.connections > 0 ? 0.95 : 0.6);
            
            const linkSelection = g.selectAll('.link');
            linkSelection.style('opacity', 0.4);
            
            if (smartPerformanceMode && currentScale < 0.1) {
                nodeSelection.style('display', null);
                linkSelection.style('display', null);
            } else if (currentScale < 0.2) {
                nodeSelection.style('display', null);
                linkSelection.style('display', null);
            } else {
                nodeSelection.style('display', null);
                linkSelection.style('display', null);
                updateLabelsVisibility();
            }
        }

        // 라벨 표시
        function updateLabelsVisibility() {
            if (!g) return;
            
            g.selectAll('.node-label').each(function(d){
                const sel = d3.select(this);
                if (d && d.type === 'service') sel.classed('visible', true);
            });
        }

        // 텍스트 자르기
        function truncateText(text, maxLength) {
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
        }

        // 툴팁 표시
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const rect = document.querySelector('.graph-container').getBoundingClientRect();
            
            tooltip.innerHTML = `
                <strong>${d.id}</strong><br>
                타입: ${getTypeLabel(d.type)}<br>
                연결: ${d.connections}개
                ${d.year ? `<br>연도: ${d.year}` : ''}
            `;
            
            tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
            tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
            tooltip.classList.add('visible');
        }

        // 툴팁 숨기기
        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        // 타입 라벨 반환
        function getTypeLabel(type) {
            const labels = {
                contract: '계약명',
                service: '수행용역'
            };
            return labels[type] || type;
        }

        // 드래그 이벤트
        function dragstarted(event, d) {
            if (!event.active && !isSimulationRunning) {
                simulation.alphaTarget(0.3).restart();
                isSimulationRunning = true;
            }
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) {
                simulation.alphaTarget(0);
                if (performanceMode) {
                    setTimeout(() => {
                        simulation.stop();
                        isSimulationRunning = false;
                    }, 1000);
                }
            }
            d.fx = null;
            d.fy = null;
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            // 검색
            document.getElementById('searchInput').addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                
                if (query) {
                    const matchingServices = allServices.filter(service => 
                        service.toLowerCase().includes(query)
                    );
                    
                    if (matchingServices.length > 0 && matchingServices.length <= 3) {
                        selectedServices.clear();
                        matchingServices.forEach(service => selectedServices.add(service));
                        updateServiceHighlighting();
                        updateServiceCount();
                        renderServiceList();
                    }
                } else {
                    if (selectedServices.size > 0) {
                        selectedServices.clear();
                        updateServiceHighlighting();
                        updateServiceCount();
                        renderServiceList();
                    }
                }
                
                applyFilters();
            });

            // 타임라인 룰러 드래그 이벤트
            let isDragging = false;
            let dragTarget = null;
            
            document.addEventListener('mousedown', (e) => {
                const handle = e.target.closest('.range-handle');
                if (handle) {
                    isDragging = true;
                    dragTarget = handle;
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging || !dragTarget) return;
                
                const ruler = document.querySelector('.timeline-ruler');
                if (!ruler) return;
                
                const rect = ruler.getBoundingClientRect();
                const x = e.clientX - rect.left - 15;
                const width = rect.width - 30;
                const percentage = Math.max(0, Math.min(100, (x / width) * 100));
                
                const minYear = Math.min(...availableYears);
                const maxYear = Math.max(...availableYears);
                const totalYears = maxYear - minYear;
                const selectedYear = Math.round(minYear + (percentage / 100) * totalYears);
                
                if (dragTarget.classList.contains('range-start')) {
                    yearRange.min = Math.max(minYear, Math.min(selectedYear, yearRange.max));
                } else {
                    yearRange.max = Math.min(maxYear, Math.max(selectedYear, yearRange.min));
                }
                
                updateRangeSelection(minYear, maxYear, yearRange.min, yearRange.max);
                updateTimelineDisplay();
                applyFilters();
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                dragTarget = null;
            });

            // 노드 타입 필터
            document.getElementById('nodeTypeFilters').addEventListener('click', (e) => {
                if (e.target.classList.contains('filter-btn')) {
                    document.querySelectorAll('#nodeTypeFilters .filter-btn').forEach(btn => 
                        btn.classList.remove('active')
                    );
                    e.target.classList.add('active');
                    applyFilters();
                }
            });

            // 줌 컨트롤
            document.getElementById('zoomIn').addEventListener('click', () => {
                const duration = smartPerformanceMode ? 150 : (performanceMode ? 200 : 400);
                svg.transition().duration(duration).call(zoom.scaleBy, 1.2);
            });

            document.getElementById('zoomOut').addEventListener('click', () => {
                const duration = smartPerformanceMode ? 150 : (performanceMode ? 200 : 400);
                svg.transition().duration(duration).call(zoom.scaleBy, 0.8);
            });

            document.getElementById('resetZoom').addEventListener('click', () => {
                const duration = smartPerformanceMode ? 300 : 600;
                svg.transition().duration(duration).call(zoom.transform, d3.zoomIdentity);
                setTimeout(() => {
                    updateNodeVisibility();
                    updateLabelsVisibility();
                }, duration + 100);
            });

            // 선택 해제 버튼
            document.getElementById('clearSelection').addEventListener('click', () => {
                clearSelection();
            });

            // 윈도우 리사이즈
            window.addEventListener('resize', throttle(() => {
                const container = document.querySelector('.graph-container');
                width = container.clientWidth;
                height = container.clientHeight;
                
                svg.attr('width', width).attr('height', height);
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                
                if (!isSimulationRunning) {
                    simulation.alpha(0.1).restart();
                    isSimulationRunning = true;
                    setTimeout(() => {
                        simulation.stop();
                        isSimulationRunning = false;
                    }, 1000);
                }
            }, 250));
        }

        // 필터 적용
        function applyFilters() {
            const searchQuery = document.getElementById('searchInput').value.toLowerCase();
            const activeType = document.querySelector('#nodeTypeFilters .filter-btn.active')?.dataset.type;

            filteredData = allData.filter(d => {
                const matchesSearch = !searchQuery || 
                    d.contract.toLowerCase().includes(searchQuery) ||
                    d.service.toLowerCase().includes(searchQuery);

                const year = parseInt(d.year);
                const matchesYear = !isNaN(year) && year >= yearRange.min && year <= yearRange.max;

                return matchesSearch && matchesYear;
            });

            createNetworkData();

            if (activeType !== 'all') {
                let allowedTypes = [];
                
                switch(activeType) {
                    case 'contract-only':
                        allowedTypes = ['contract'];
                        break;
                    case 'service-only':
                        allowedTypes = ['service'];
                        break;
                }
                
                nodes = nodes.filter(node => allowedTypes.includes(node.type));
                links = links.filter(link => {
                    const sourceNode = nodes.find(n => n.id === link.source);
                    const targetNode = nodes.find(n => n.id === link.target);
                    return sourceNode && targetNode;
                });
            }

            clearSelection();
            renderGraph();
            updateStats();
        }

        // 통계 업데이트
        function updateStats() {
            document.getElementById('totalNodes').textContent = nodes.length.toLocaleString();
            document.getElementById('totalLinks').textContent = links.length.toLocaleString();
            document.getElementById('visibleNodes').textContent = nodes.length.toLocaleString();
        }

        // 수행용역 브라우저 초기화
        function initializeServiceBrowser() {
            const serviceSet = new Set();
            allData.forEach(d => {
                if (d.service && d.service.trim()) {
                    serviceSet.add(d.service.trim());
                }
            });
            
            allServices = Array.from(serviceSet).sort((a, b) => a.localeCompare(b, 'ko'));
            
            console.log(`수행용역 ${allServices.length}개 추출 완료:`, allServices);
            
            renderServiceList();
            setupServiceBrowserEvents();
            updateServiceCount();
        }

        // 수행용역 리스트 렌더링
        function renderServiceList(searchQuery = '') {
            const serviceList = document.getElementById('serviceList');
            const filteredServices = allServices.filter(service => 
                service.toLowerCase().includes(searchQuery.toLowerCase())
            );
            
            serviceList.innerHTML = '';
            
            filteredServices.forEach(service => {
                const contractCount = allData.filter(d => d.service === service).length;
                
                const serviceItem = document.createElement('div');
                serviceItem.className = 'service-item';
                serviceItem.innerHTML = `
                    <input type="checkbox" class="service-checkbox" data-service="${service}" ${selectedServices.has(service) ? 'checked' : ''}>
                    <span class="service-label ${selectedServices.has(service) ? 'selected' : ''}">${service}</span>
                    <span class="service-count">${contractCount}</span>
                `;
                
                if (selectedServices.has(service)) {
                    serviceItem.classList.add('highlighted');
                }
                
                serviceList.appendChild(serviceItem);
            });
        }

        // 수행용역 브라우저 이벤트 설정
        function setupServiceBrowserEvents() {
            const serviceSearch = document.getElementById('serviceSearch');
            serviceSearch.addEventListener('input', (e) => {
                const query = e.target.value;
                renderServiceList(query);
                
                const matchingCount = allServices.filter(service => 
                    service.toLowerCase().includes(query.toLowerCase())
                ).length;
                
                if (query && matchingCount === 0) {
                    e.target.style.borderColor = '#ef4444';
                    e.target.placeholder = '일치하는 수행용역이 없습니다';
                } else {
                    e.target.style.borderColor = query ? '#10b981' : '#d1d5db';
                    e.target.placeholder = query ? `${matchingCount}개 수행용역 발견` : '수행용역 검색...';
                }
            });

            const serviceList = document.getElementById('serviceList');
            serviceList.addEventListener('change', (e) => {
                if (e.target.classList.contains('service-checkbox')) {
                    const service = e.target.dataset.service;
                    const isChecked = e.target.checked;
                    
                    if (isChecked) {
                        selectedServices.add(service);
                    } else {
                        selectedServices.delete(service);
                    }
                    
                    updateServiceHighlighting();
                    updateServiceCount();
                    renderServiceList(serviceSearch.value);
                }
            });

            serviceList.addEventListener('click', (e) => {
                if (e.target.classList.contains('service-label')) {
                    const checkbox = e.target.parentElement.querySelector('.service-checkbox');
                    checkbox.click();
                }
            });

            document.getElementById('selectAllServices').addEventListener('click', () => {
                allServices.forEach(service => selectedServices.add(service));
                updateServiceHighlighting();
                updateServiceCount();
                renderServiceList(serviceSearch.value);
            });

            document.getElementById('clearAllServices').addEventListener('click', () => {
                selectedServices.clear();
                updateServiceHighlighting();
                updateServiceCount();
                renderServiceList(serviceSearch.value);
            });

            document.getElementById('showSelectedOnly').addEventListener('click', (e) => {
                showSelectedOnly = !showSelectedOnly;
                e.target.classList.toggle('active');
                e.target.textContent = showSelectedOnly ? '모두 보기' : '선택만 보기';
                updateServiceHighlighting();
            });
        }

        // 선택된 수행용역 수 업데이트
        function updateServiceCount() {
            const count = selectedServices.size;
            const total = allServices.length;
            document.getElementById('selectedServiceCount').textContent = `${count}/${total}`;
        }

        // 수행용역 선택에 따른 그래프 하이라이팅
        function updateServiceHighlighting() {
            if (!g) return;

            if (selectedServices.size === 0) {
                g.selectAll('.node')
                    .classed('blurred', false)
                    .classed('highlighted', false)
                    .classed('service-selected', false);
                
                g.selectAll('.link')
                    .classed('blurred', false)
                    .classed('highlighted', false);
                    
                g.selectAll('.node-label')
                    .classed('service-highlighted', false);
                
                return;
            }

            const selectedServiceNodes = new Set();
            const connectedContractNodes = new Set();
            const highlightedLinks = new Set();

            nodes.forEach(node => {
                if (node.type === 'service' && selectedServices.has(node.id)) {
                    selectedServiceNodes.add(node.id);
                }
            });

            links.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                
                if (selectedServiceNodes.has(sourceId)) {
                    connectedContractNodes.add(targetId);
                    highlightedLinks.add(link);
                } else if (selectedServiceNodes.has(targetId)) {
                    connectedContractNodes.add(sourceId);
                    highlightedLinks.add(link);
                }
            });

            const allRelatedNodes = new Set([...selectedServiceNodes, ...connectedContractNodes]);

            if (showSelectedOnly) {
                g.selectAll('.node')
                    .style('display', d => allRelatedNodes.has(d.id) ? null : 'none');
                
                g.selectAll('.link')
                    .style('display', d => highlightedLinks.has(d) ? null : 'none');
            } else {
                g.selectAll('.node')
                    .style('display', null);
                
                g.selectAll('.link')
                    .style('display', null);
                
                g.selectAll('.node')
                    .classed('blurred', d => !allRelatedNodes.has(d.id))
                    .classed('highlighted', d => allRelatedNodes.has(d.id))
                    .classed('service-selected', d => selectedServiceNodes.has(d.id));
                
                g.selectAll('.link')
                    .classed('blurred', d => !highlightedLinks.has(d))
                    .classed('highlighted', d => highlightedLinks.has(d));
            }

            g.selectAll('.node-label')
                .classed('service-highlighted', d => allRelatedNodes.has(d.id));
                
            document.getElementById('clearSelection').classList.add('visible');
        }
    </script>
</body>
</html>
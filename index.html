<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EAN ê³„ì•½ ë„¤íŠ¸ì›Œí¬</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.4.2/dist/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link rel="preload" href="styles.css?v=2024090701" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="styles.css?v=2024090701"></noscript>
    <style>
        /* ê²€ìƒ‰ í•˜ì´ë¼ì´íŠ¸ ìŠ¤íƒ€ì¼ */
        .node.search-match {
            stroke: #fbbf24 !important;
            stroke-width: 3px !important;
        }
        .node.search-dim {
            opacity: 0.3;
        }
        /* ë…¸ë“œ ì„ íƒ ìŠ¤íƒ€ì¼ */
        .node.highlighted {
            stroke: #ef4444 !important;
            stroke-width: 3px !important;
        }
        .node.blurred {
            opacity: 0.3;
        }
        .link.highlighted {
            stroke: #ef4444 !important;
            stroke-width: 3px !important;
        }
        .link.blurred {
            opacity: 0.2;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="graph-container">
            <!-- ë¡œë”© í™”ë©´ -->
            <div class="loading" id="loading">
                <div class="eco-spinner"></div>
                <div class="loading-text">
                    <span class="en-text">Connecting the network footprints of EAN</span><br>
                    <span class="en-sub-text">Architectural group in environmental, ecological, and energy fields</span><br>
                    <span class="en-wait">Please wait a moment</span><br><br>
                    <span class="ko-text">í™˜ê²½Â·ìƒíƒœÂ·ì—ë„ˆì§€ ë¶„ì•¼ ê±´ì¶•ì¸ ê·¸ë£¹ EANì˜</span><br>
                    <span class="ko-sub-text">ë„¤íŠ¸ì›Œí¬ ë°œìì·¨ë¥¼ ì—°ê²°í•˜ê³  ìˆìŠµë‹ˆë‹¤</span><br>
                    <span class="ko-wait">ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”</span>
                </div>
            </div>
            
            <!-- í”Œë¡œíŒ… ì»¨íŠ¸ë¡¤ íŒ¨ë„ -->
            <div class="floating-controls">
                <div class="control-group">
                    <label>ê²€ìƒ‰</label>
                    <input type="text" class="search-input" id="searchInput" placeholder="ê³„ì•½ëª…, ìˆ˜í–‰ìš©ì—­ ê²€ìƒ‰..." style="width: 100%;">
                    <div class="zoom-controls-inline" style="justify-content: center; margin-top: 12px;">
                        <button class="zoom-btn" id="zoomIn">+</button>
                        <button class="zoom-btn" id="zoomOut">âˆ’</button>
                        <button class="zoom-btn" id="resetZoom">âŒ‚</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>íšŒì‚¬ ì—°ëŒ€ê¸°</label>
                    <div class="year-selector-container">
                        <div class="year-selector">
                            <div class="year-input-group">
                                <label for="startYear">ì‹œì‘:</label>
                                <select id="startYear" class="year-dropdown">
                                    <option value="2020">2020</option>
                                    <option value="2021">2021</option>
                                    <option value="2022">2022</option>
                                    <option value="2023">2023</option>
                                    <option value="2024">2024</option>
                                </select>
                            </div>
                            <div class="year-input-group">
                                <label for="endYear">ë:</label>
                                <select id="endYear" class="year-dropdown">
                                    <option value="2020">2020</option>
                                    <option value="2021">2021</option>
                                    <option value="2022">2022</option>
                                    <option value="2023">2023</option>
                                    <option value="2024" selected>2024</option>
                                </select>
                            </div>
                        </div>
                        <div class="timeline-display">
                            <div class="timeline-period">
                                <span class="period-label">EAN ì—¬ì •</span>
                                <span class="period-range">
                                    <span id="timelineStart">2020</span>
                                    <span class="period-arrow">â†’</span>
                                    <span id="timelineEnd">2024</span>
                                </span>
                            </div>
                        </div>
                        
                        <div class="timeline-stats">
                            <div class="stat-item">
                                <span class="stat-label">ì´ ë…¸ë“œ:</span>
                                <span class="stat-value" id="totalNodes">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">ì—°ê²°:</span>
                                <span class="stat-value" id="totalLinks">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">í‘œì‹œëœ ë…¸ë“œ:</span>
                                <span class="stat-value" id="visibleNodes">0</span>
                            </div>
                            <div class="stat-item" id="selectedNodeInfo" style="display: none;">
                                <span class="stat-label">ì„ íƒëœ ë…¸ë“œ:</span>
                                <span class="stat-value" id="selectedNodeName">-</span>
                            </div>
                            <div class="stat-item" id="relatedCountInfo" style="display: none;">
                                <span class="stat-label">ê´€ë ¨ ê³„ì•½:</span>
                                <span class="stat-value" id="relatedCount">0</span>
                            </div>
                            <div class="stat-item" id="linkCountInfo" style="display: none;">
                                <span class="stat-label">ì—°ê²° ë§í¬:</span>
                                <span class="stat-value" id="linkCount">0</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="inline-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3b82f6; width: 16px; height: 16px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
                            <span style="font-weight: 600; font-size: 14px;">ìˆ˜í–‰ìš©ì—­</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #10b981; width: 16px; height: 16px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
                            <span style="font-weight: 600; font-size: 14px;">ê³„ì•½ëª…</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- í”Œë¡œíŒ… ì˜¤ë²„ë ˆì´ ì¹´ë“œë“¤ -->
            <div class="overlay-cards">
                <div class="overlay-card">
                    <h3>
                        ìˆ˜í–‰ìš©ì—­
                        <span id="selectedServiceCount" style="font-size: 12px; color: #6b7280;">0/43</span>
                    </h3>
                    
                    <input type="text" class="service-search" id="serviceSearch" placeholder="ìˆ˜í–‰ìš©ì—­ ê²€ìƒ‰...">
                    
                    <div class="service-controls">
                        <button class="service-control-btn" id="selectAllServices">ëª¨ë‘ ì„ íƒ</button>
                        <button class="service-control-btn" id="clearAllServices">ëª¨ë‘ í•´ì œ</button>
                        <button class="service-control-btn" id="showSelectedOnly">ì„ íƒë§Œ ë³´ê¸°</button>
                    </div>
                    
                    <div class="service-list" id="serviceList">
                        <!-- ìˆ˜í–‰ìš©ì—­ ë¦¬ìŠ¤íŠ¸ê°€ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                    </div>
                </div>
            </div>
            
            <button class="clear-selection" id="clearSelection">ì„ íƒ í•´ì œ</button>
            
            <div id="graph-container"></div>
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜ (PIXI.js ê¸°ë°˜)
        let allData = [];
        let filteredData = [];
        let nodes = [];
        let links = [];
        let simulation;
        let app, viewport;
        let nodeContainer, linkContainer;
        let width, height;
        let selectedNode = null;
        let currentScale = 1;
        let selectedServices = new Set();
        let allServices = [];
        let showSelectedOnly = false;
        let yearRange = { min: 2020, max: 2024 };
        let availableYears = [];

        // EAN í…Œí¬ë†€ë¡œì§€ ë¸Œëœë“œ ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ (í™ˆí˜ì´ì§€ ì‚½ì…ìš© ìµœì í™”)
        const EAN_COLORS = {
            // ë©”ì¸ ë¸Œëœë“œ ì»¬ëŸ¬
            primary_blue: 0x1e40af,      // EAN ë©”ì¸ ë¸”ë£¨ #1e40af
            primary_green: 0x059669,     // EAN ë©”ì¸ ê·¸ë¦° #059669
            brand_white: 0xffffff,       // ë¸Œëœë“œ í™”ì´íŠ¸
            
            // ì„œë¹„ìŠ¤ ë…¸ë“œ ê³„ì—´ (íŒŒë€ìƒ‰ í†¤)
            service_main: 0x3b82f6,      // ë°ì€ ë¸”ë£¨ #3b82f6
            service_hover: 0x2563eb,     // í˜¸ë²„ ë¸”ë£¨ #2563eb
            service_selected: 0x1d4ed8,  // ì„ íƒ ë¸”ë£¨ #1d4ed8
            
            // ê³„ì•½ ë…¸ë“œ ê³„ì—´ (ë…¹ìƒ‰ í†¤)
            contract_main: 0x10b981,     // ë°ì€ ê·¸ë¦° #10b981
            contract_hover: 0x059669,    // í˜¸ë²„ ê·¸ë¦° #059669
            contract_selected: 0x047857, // ì„ íƒ ê·¸ë¦° #047857
            
            // UI ê³„ì¸µ ì»¬ëŸ¬
            background: 0xf8fafc,        // ì•„ì£¼ ë°ì€ íšŒìƒ‰ ë°°ê²½
            text_primary: 0x1f2937,      // ì£¼ìš” í…ìŠ¤íŠ¸ (ì§„í•œ íšŒìƒ‰)
            text_secondary: 0x6b7280,    // ë³´ì¡° í…ìŠ¤íŠ¸ (ì¤‘ê°„ íšŒìƒ‰)
            text_muted: 0x9ca3af,        // íë¦° í…ìŠ¤íŠ¸ (ë°ì€ íšŒìƒ‰)
            
            // ë§í¬ ì»¬ëŸ¬
            link_default: 0xe5e7eb,      // ê¸°ë³¸ ë§í¬ #e5e7eb
            link_active: 0x3b82f6,       // í™œì„± ë§í¬ (ë¸”ë£¨)
            link_highlighted: 0x10b981,  // ê°•ì¡° ë§í¬ (ê·¸ë¦°)
            
            // ê°•ì¡° ë° í•˜ì´ë¼ì´íŠ¸
            accent_gold: 0xf59e0b,       // ì„ íƒ ê°•ì¡° ê³¨ë“œ
            accent_warning: 0xef4444,    // ê²½ê³ /ì—ëŸ¬
            accent_success: 0x10b981,    // ì„±ê³µ (ê·¸ë¦°)
        };
        let isSimulationRunning = false;
        
        // PIXI.js ê´€ë ¨ ë³€ìˆ˜
        let nodeGraphics = new Map();
        let linkGraphics = new Map();
        
        // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë³€ìˆ˜
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        // EAN ë¸Œëœë“œ ê¸°ë°˜ ë…¸ë“œ ìƒ‰ìƒ í•¨ìˆ˜
        function getNodeColor(node, state = 'default') {
            const type = node.type;
            
            if (type === 'service') {
                switch(state) {
                    case 'hover': return EAN_COLORS.service_hover;
                    case 'selected': return EAN_COLORS.service_selected;
                    default: return EAN_COLORS.service_main;
                }
            } else { // contract
                switch(state) {
                    case 'hover': return EAN_COLORS.contract_hover;
                    case 'selected': return EAN_COLORS.contract_selected;
                    default: return EAN_COLORS.contract_main;
                }
            }
        }

        // ë§í¬ ìƒ‰ìƒ í•¨ìˆ˜
        function getLinkColor(state = 'default') {
            switch(state) {
                case 'active': return EAN_COLORS.link_active;
                case 'highlighted': return EAN_COLORS.link_highlighted;
                default: return EAN_COLORS.link_default;
            }
        }

        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await loadData();
                initGraph();
                setupEventListeners();
                updateStats();
            } catch (error) {
                console.error('ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ef4444;">âŒ ë°ì´í„° ë¡œë”© ì‹¤íŒ¨</div>
                    <div style="font-size: 12px; margin-top: 10px;">JSON ë°ì´í„° íŒŒì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.</div>
                `;
            }
        });

        // ë°ì´í„° ë¡œë“œ (JSON ì „ìš©)
        async function loadData() {
            try {
                console.log('JSON ë°ì´í„° ë¡œë“œ ì¤‘...');
                const startTime = performance.now();
                
                const response = await fetch('data.json');
                if (!response.ok) {
                    throw new Error(`HTTP ì˜¤ë¥˜: ${response.status} - ${response.statusText}`);
                }
                
                const jsonData = await response.json();
                console.log('JSON êµ¬ì¡° í™•ì¸:', Object.keys(jsonData));
                
                if (!jsonData.records || !jsonData.lookup) {
                    throw new Error('JSON êµ¬ì¡° ì˜¤ë¥˜: records ë˜ëŠ” lookup ëˆ„ë½');
                }
                
                console.log(`JSON ë¡œë“œ ì™„ë£Œ: ${jsonData.records.length.toLocaleString()}ê°œ ë ˆì½”ë“œ`);
                
                allData = jsonData.records.map((record, index) => {
                    if (!record || record.length < 3) {
                        console.warn(`ì˜ëª»ëœ ë ˆì½”ë“œ ${index}:`, record);
                        return null;
                    }
                    
                    const [yearIdx, contractIdx, serviceIdx] = record;
                    const year = jsonData.lookup.years[yearIdx];
                    const contract = jsonData.lookup.contracts[contractIdx];
                    const service = jsonData.lookup.services[serviceIdx];
                    
                    if (!year || !contract || !service) {
                        console.warn(`ë§¤í•‘ ì‹¤íŒ¨ ${index}:`, {
                            yearIdx, year,
                            contractIdx, contract, 
                            serviceIdx, service
                        });
                        return null;
                    }
                    
                    return { year, contract, service };
                }).filter(item => item !== null);
                
                const endTime = performance.now();
                console.log(`JSON íŒŒì‹± ì™„ë£Œ: ${allData.length.toLocaleString()}ê°œ í•­ëª© (${(endTime - startTime).toFixed(1)}ms)`);
                
                if (allData.length === 0) {
                    throw new Error('ë°ì´í„° ë§¤í•‘ ê²°ê³¼ê°€ ë¹„ì–´ìˆìŒ');
                }
                
                // ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ
                filteredData = [...allData];
                createNetworkData();
                initializeTimelineRuler();
                initializeServiceBrowser();
                
            } catch (error) {
                console.error('JSON ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ef4444;">âŒ JSON ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨</div>
                    <div style="font-size: 12px; margin-top: 10px; color: #6b7280;">
                        ì˜¤ë¥˜: ${error.message}<br>
                        ë¸Œë¼ìš°ì € ì½˜ì†”(F12)ì—ì„œ ìƒì„¸ ì˜¤ë¥˜ë¥¼ í™•ì¸í•˜ì„¸ìš”.
                    </div>
                `;
                throw error;
            }
        }

        // ë„¤íŠ¸ì›Œí¬ ë°ì´í„° ìƒì„± (ë¬´ê²°ì„± ê²€ì¦ ê°•í™”)
        function createNetworkData() {
            console.log('ë„¤íŠ¸ì›Œí¬ ë°ì´í„° ìƒì„± ì‹œì‘...', filteredData.length, 'ê°œ í•­ëª©');
            
            const nodeMap = new Map();
            const linkMap = new Map();
            let processedCount = 0;
            let errorCount = 0;

            filteredData.forEach((d, index) => {
                // ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦
                if (!d || typeof d.contract === 'undefined' || typeof d.service === 'undefined') {
                    console.warn(`ì˜ëª»ëœ ë°ì´í„° í•­ëª© ${index}:`, d);
                    errorCount++;
                    return;
                }
                
                if (!d.contract || d.contract === '' || !d.service || d.service === '') {
                    console.warn(`ë¹„ì–´ìˆëŠ” ë°ì´í„° ${index}:`, d);
                    errorCount++;
                    return;
                }
                
                // ê³„ì•½ëª… ë…¸ë“œ
                const contractId = String(d.contract).trim();
                if (!nodeMap.has(contractId)) {
                    nodeMap.set(contractId, {
                        id: contractId,
                        type: 'contract',
                        year: d.year,
                        connections: 0
                    });
                }

                // ìˆ˜í–‰ìš©ì—­ ë…¸ë“œ
                const serviceId = String(d.service).trim();
                if (!nodeMap.has(serviceId)) {
                    nodeMap.set(serviceId, {
                        id: serviceId,
                        type: 'service',
                        connections: 0
                    });
                }

                // ë§í¬ ìƒì„±
                const linkId = `${contractId}|${serviceId}`;
                if (!linkMap.has(linkId)) {
                    linkMap.set(linkId, {
                        source: contractId,
                        target: serviceId,
                        weight: 1
                    });
                    nodeMap.get(contractId).connections++;
                    nodeMap.get(serviceId).connections++;
                } else {
                    linkMap.get(linkId).weight++;
                }
                
                processedCount++;
            });

            nodes = Array.from(nodeMap.values());
            links = Array.from(linkMap.values());
            
            const contractNodes = nodes.filter(n => n.type === 'contract').length;
            const serviceNodes = nodes.filter(n => n.type === 'service').length;
            
            console.log(`ë„¤íŠ¸ì›Œí¬ ë°ì´í„° ìƒì„± ì™„ë£Œ:`, {
                totalRecords: filteredData.length,
                processed: processedCount,
                errors: errorCount,
                totalNodes: nodes.length,
                contractNodes: contractNodes,
                serviceNodes: serviceNodes,
                links: links.length,
                expectedNodes: `ê³„ì•½ ${contractNodes} + ì„œë¹„ìŠ¤ ${serviceNodes} = ${contractNodes + serviceNodes}`
            });
            
            // ë¬´ê²°ì„± ê²€ì¦ ê²°ê³¼ ì¶œë ¥
            if (errorCount > 0) {
                console.warn(`ë°ì´í„° ë¬´ê²°ì„± ë¬¸ì œ: ${errorCount}ê°œ í•­ëª©ì—ì„œ ì˜¤ë¥˜ ë°œê²¬`);
            }
        }

        // ê·¸ë˜í”„ ì´ˆê¸°í™” (ê°„ì†Œí™”)
        function initGraph() {
            console.log('PIXI.js WebGL ê·¸ë˜í”„ ì´ˆê¸°í™”...');
            
            const container = document.querySelector('.graph-container');
            width = container.clientWidth;
            height = container.clientHeight;

            // PIXI.js Application ìƒì„± (WebGL í™œì„±í™”)
            app = new PIXI.Application({
                width: width,
                height: height,
                backgroundColor: 0xf8fafc, // ë°°ê²½ìƒ‰
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                powerPreference: 'high-performance' // GPU ì„±ëŠ¥ ìš°ì„ 
            });

            // ì»¨í…Œì´ë„ˆì— PIXI ìº”ë²„ìŠ¤ ì¶”ê°€
            const graphContainer = document.getElementById('graph-container');
            graphContainer.appendChild(app.view);

            // ë·°í¬íŠ¸ ì»¨í…Œì´ë„ˆ ìƒì„± (ì¤Œ/íŒ¬ìš©)
            viewport = new PIXI.Container();
            app.stage.addChild(viewport);

            // ë Œë”ë§ ë ˆì´ì–´ ìƒì„±
            linkContainer = new PIXI.Container();
            nodeContainer = new PIXI.Container();
            viewport.addChild(linkContainer);
            viewport.addChild(nodeContainer);

            // ê¸°ë³¸ ì¤Œ/íŒ¬ ì„¤ì •
            setupInteractions();

            // ì´ˆê¸° ì¤Œ ë ˆë²¨ ì„¤ì • (ì¤Œ ì•„ì›ƒëœ ìƒíƒœì—ì„œ ì‹œì‘)
            currentScale = 0.2;
            viewport.scale.set(currentScale);
            viewport.position.set(width * 1.95 * currentScale, height * 1.95 * currentScale);

            // D3.js force simulation ì„¤ì • (5ë°° ë” ë„“ì€ ê°„ê²©ìœ¼ë¡œ ì„¤ì •)
            simulation = d3.forceSimulation()
                .force('link', d3.forceLink().id(d => d.id).distance(1100).strength(0.2))  // 220 * 5 = 1100, ê°•ë„ ë”ìš± ê°ì†Œ
                .force('charge', d3.forceManyBody().strength(-3000).distanceMax(4000))      // -600 * 5 = -3000, distanceMax * 5
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => getNodeSize(d) + 75).strength(0.3))  // 15 * 5 = 75, ê°•ë„ ë”ìš± ê°ì†Œ
                .alphaMin(0.001)        // ìµœì†Œ ì•ŒíŒŒê°’ ì„¤ì • (ë” ë¹¨ë¦¬ ì•ˆì •í™”)
                .alphaDecay(0.0228)     // ì•ŒíŒŒ ê°ì‡ ìœ¨ ì¦ê°€ (ë” ë¹¨ë¦¬ ì•ˆì •í™”)
                .velocityDecay(0.4);    // ì†ë„ ê°ì‡  ì„¤ì • (ì›€ì§ì„ ë¹¨ë¦¬ ë©ˆì¶¤)

            renderGraph();
            
            // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘
            startPerformanceMonitoring();
            
            console.log('PIXI.js WebGL ì´ˆê¸°í™” ì™„ë£Œ');
        }
        
        // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘
        function startPerformanceMonitoring() {
            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - lastTime >= 1000) {
                    fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                    frameCount = 0;
                    lastTime = currentTime;
                    
                    // FPSë¥¼ UIì— í‘œì‹œ
                    updatePerformanceStats();
                }
                
                requestAnimationFrame(updateFPS);
            }
            
            requestAnimationFrame(updateFPS);
        }
        
        // ì„±ëŠ¥ í†µê³„ ì—…ë°ì´íŠ¸
        function updatePerformanceStats() {
            // ì½˜ì†”ì— ì„±ëŠ¥ ì •ë³´ ì¶œë ¥
            console.log(`FPS: ${fps}, Nodes: ${nodes.length}, Links: ${links.length}, WebGL: ${app.renderer.type === 1 ? 'Yes' : 'No'}`);
            
            // í˜ì´ì§€ì— ì„±ëŠ¥ ì •ë³´ í‘œì‹œ (ê°œë°œììš©)
            if (!document.getElementById('performance-stats')) {
                const perfDiv = document.createElement('div');
                perfDiv.id = 'performance-stats';
                perfDiv.style.position = 'fixed';
                perfDiv.style.top = '10px';
                perfDiv.style.left = '10px';
                perfDiv.style.background = 'rgba(0,0,0,0.8)';
                perfDiv.style.color = 'white';
                perfDiv.style.padding = '10px';
                perfDiv.style.borderRadius = '5px';
                perfDiv.style.fontFamily = 'monospace';
                perfDiv.style.fontSize = '12px';
                perfDiv.style.zIndex = '10000';
                document.body.appendChild(perfDiv);
            }
            
            const perfDiv = document.getElementById('performance-stats');
            perfDiv.innerHTML = `
                FPS: ${fps}<br>
                Nodes: ${nodes.length}<br>
                Links: ${links.length}<br>
                WebGL: ${app.renderer.type === 1 ? 'Yes' : 'No'}<br>
                Scale: ${currentScale.toFixed(2)}
            `;
        }

        // PIXI.js ì¸í„°ë™ì…˜ ì„¤ì •
        function setupInteractions() {
            let isDragging = false;
            let dragStart = { x: 0, y: 0 };

            app.view.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragStart.x = e.clientX - viewport.position.x;
                dragStart.y = e.clientY - viewport.position.y;
            });

            app.view.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    viewport.position.x = e.clientX - dragStart.x;
                    viewport.position.y = e.clientY - dragStart.y;
                }
            });

            app.view.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // íœ  ì¤Œ ì§€ì›
            app.view.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.1, Math.min(4, currentScale * scaleFactor));
                
                if (newScale !== currentScale) {
                    const worldPos = {
                        x: (e.clientX - viewport.position.x) / currentScale,
                        y: (e.clientY - viewport.position.y) / currentScale
                    };
                    
                    currentScale = newScale;
                    viewport.scale.set(currentScale);
                    
                    viewport.position.x = e.clientX - worldPos.x * currentScale;
                    viewport.position.y = e.clientY - worldPos.y * currentScale;
                }
            });
        }

        // PIXI.js ê·¸ë˜í”„ ë Œë”ë§ (WebGL ê¸°ë°˜)
        function renderGraph() {
            console.log('PIXI.js WebGL ë Œë”ë§ ì‹œì‘...', nodes.length, 'ê°œ ë…¸ë“œ,', links.length, 'ê°œ ë§í¬');
            
            if (!nodes || nodes.length === 0) {
                console.error('ë…¸ë“œê°€ ë¹„ì–´ìˆìŒ!');
                return;
            }
            
            // ê¸°ì¡´ ê·¸ë˜í”½ ìš”ì†Œ í´ë¦¬ì–´
            linkContainer.removeChildren();
            nodeContainer.removeChildren();
            nodeGraphics.clear();
            linkGraphics.clear();

            // ìƒ‰ìƒ ë³€í™˜ í•¨ìˆ˜ (ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•Šì§€ë§Œ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€)
            function hexToPixiColor(hex) {
                return parseInt(hex.replace('#', '0x'));
            }

            // ë§í¬ ë Œë”ë§ (PIXI Graphics) - EAN ë¸Œëœë“œ ì»¬ëŸ¬ ì ìš©
            console.log('ë§í¬ ë Œë”ë§ ì¤‘...');
            links.forEach((link, index) => {
                const linkGraphic = new PIXI.Graphics();
                
                // ë§í¬ ë‘ê»˜ëŠ” ì—°ê²° ê°•ë„ì— ë”°ë¼, ìƒ‰ìƒì€ EAN ë¸Œëœë“œ ì»¬ëŸ¬ë¡œ
                const thickness = link.weight ? Math.sqrt(link.weight) + 1 : 1.5;
                linkGraphic.lineStyle(thickness, getLinkColor('default'), 0.5); // EAN ê¸°ë³¸ ë§í¬ ìƒ‰ìƒ
                
                linkGraphic.moveTo(0, 0).lineTo(100, 100); // ì„ì‹œ ìœ„ì¹˜, tickì—ì„œ ì—…ë°ì´íŠ¸
                linkContainer.addChild(linkGraphic);
                linkGraphics.set(index, linkGraphic);
            });

            // ë…¸ë“œ ë Œë”ë§ (PIXI Graphics) - EAN ë¸Œëœë“œ ì»¬ëŸ¬ ì ìš©
            console.log('ë…¸ë“œ ë Œë”ë§ ì¤‘...');
            nodes.forEach((node, index) => {
                const nodeGraphic = new PIXI.Graphics();
                const radius = getNodeSize(node);
                const fillColor = getNodeColor(node, 'default');
                
                // EAN ë¸Œëœë“œ ìŠ¤íƒ€ì¼: ìƒ‰ìƒ ë…¸ë“œ + í°ìƒ‰ í…Œë‘ë¦¬
                nodeGraphic.beginFill(fillColor);
                nodeGraphic.lineStyle(2, EAN_COLORS.brand_white, 0.9); // ë¸Œëœë“œ í™”ì´íŠ¸ í…Œë‘ë¦¬
                nodeGraphic.drawCircle(0, 0, radius);
                nodeGraphic.endFill();
                
                // ì¸í„°ë™í‹°ë¸Œ ì„¤ì •
                nodeGraphic.interactive = true;
                nodeGraphic.cursor = 'pointer';
                nodeGraphic.userData = node;
                
                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (í–¥ìƒëœ í˜¸ë²„ íš¨ê³¼ í¬í•¨)
                nodeGraphic.on('pointerover', (event) => {
                    showTooltipPIXI(event, node);
                    onNodeHover(nodeGraphic, node, true); // í˜¸ë²„ ì‹œì‘
                });
                nodeGraphic.on('pointerout', (event) => {
                    hideTooltip();
                    onNodeHover(nodeGraphic, node, false); // í˜¸ë²„ ì¢…ë£Œ
                });
                
                // ë“œë˜ê·¸ ì´ë²¤íŠ¸ ì„¤ì • (í¬í•¨ëœ pointerup í•¸ë“¤ëŸ¬ê°€ í´ë¦­ë„ ì²˜ë¦¬)
                setupNodeDrag(nodeGraphic, node);
                
                nodeContainer.addChild(nodeGraphic);
                nodeGraphics.set(node.id, nodeGraphic);
            });

            // í…ìŠ¤íŠ¸ ë¼ë²¨ ì¶”ê°€ (ëª¨ë“  ë…¸ë“œì— ì¶”ê°€ - ì¤Œ ë ˆë²¨ì— ë”°ë¼ í‘œì‹œ)
            console.log('ë¼ë²¨ ë Œë”ë§ ì¤‘...');
            nodes.forEach(node => {
                // í…ìŠ¤íŠ¸ í¬ê¸°ë¥¼ í¬ê²Œ í•˜ë˜ ê¹”ë”í•˜ê²Œ (20px)
                const baseFontSize = 20;
                const text = new PIXI.Text(truncateText(node.id, 18), {
                    fontSize: baseFontSize,
                    fill: node.type === 'service' ? EAN_COLORS.text_primary : EAN_COLORS.text_secondary,
                    align: 'center',
                    fontWeight: 'bold',
                    fontFamily: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
                    // strokeì™€ ê·¸ë¦¼ì ì œê±°
                });
                text.anchor.set(0.5);
                text.userData = node;
                
                // ì´ˆê¸° ìƒíƒœ: ì¤Œ ë ˆë²¨ì— ë”°ë¼ í‘œì‹œ ì—¬ë¶€ ê²°ì •
                text.visible = shouldShowLabel(node, currentScale);
                
                nodeContainer.addChild(text);
                
                // ë¼ë²¨ ê·¸ë˜í”½ ë§µì— ì €ì¥ (ì—…ë°ì´íŠ¸ìš©)
                const labelKey = `label_${node.id}`;
                nodeGraphics.set(labelKey, text);
            });

            console.log('PIXI.js ë Œë”ë§ ì™„ë£Œ:', {
                linkElements: links.length,
                nodeElements: nodes.length, 
                labelElements: nodes.length
            });

            // ë°°ê²½ í´ë¦­ ì‹œ ì„ íƒ í•´ì œ
            app.view.addEventListener('click', (e) => {
                if (e.target === app.view) {
                    clearSelection();
                }
            });

            // D3.js ì‹œë®¬ë ˆì´ì…˜ ì„¤ì •
            simulation.nodes(nodes);
            simulation.force('link').links(links);

            // PIXI.js tick í•¨ìˆ˜ (ê³ ì„±ëŠ¥ + ì•ˆì •í™” ì²´í¬)
            simulation.on('tick', () => {
                // ì‹œë®¬ë ˆì´ì…˜ ì•ˆì •í™” ì²´í¬
                if (simulation.alpha() < 0.005) {
                    simulation.stop();
                    console.log('ì‹œë®¬ë ˆì´ì…˜ ì•ˆì •í™”ë¡œ ì¸í•œ ìë™ ì •ì§€');
                    return;
                }
                // ë§í¬ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì„ íƒ ìƒíƒœ ìœ ì§€)
                links.forEach((link, index) => {
                    const linkGraphic = linkGraphics.get(index);
                    if (linkGraphic) {
                        linkGraphic.clear();
                        
                        // ì„ íƒëœ ë…¸ë“œê°€ ìˆëŠ” ê²½ìš° í•˜ì´ë¼ì´íŠ¸ ìƒíƒœ ìœ ì§€
                        if (selectedNode) {
                            const isConnected = (link.source.id === selectedNode.id || link.target.id === selectedNode.id);
                            if (isConnected) {
                                linkGraphic.lineStyle(3, EAN_COLORS.link_highlighted, 1.0);
                            } else {
                                linkGraphic.lineStyle(1, EAN_COLORS.text_muted, 0.08);
                            }
                        } else {
                            // ê¸°ë³¸ ìƒíƒœ
                            linkGraphic.lineStyle(
                                link.weight ? Math.sqrt(link.weight) + 1 : 1, 
                                0x999999, 
                                0.4
                            );
                        }
                        
                        linkGraphic.moveTo(link.source.x, link.source.y);
                        linkGraphic.lineTo(link.target.x, link.target.y);
                    }
                });

                // ë…¸ë“œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                nodes.forEach(node => {
                    const nodeGraphic = nodeGraphics.get(node.id);
                    if (nodeGraphic) {
                        nodeGraphic.position.set(node.x, node.y);
                    }
                    
                    // ë¼ë²¨ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ëª¨ë“  ë…¸ë“œ) - ë” í° ê°„ê²©ìœ¼ë¡œ
                    const labelGraphic = nodeGraphics.get(`label_${node.id}`);
                    if (labelGraphic) {
                        labelGraphic.position.set(node.x, node.y + getNodeSize(node) + 20);
                    }
                });
            });

            // ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘
            simulation.alpha(1).restart();
            isSimulationRunning = true;
            console.log('PIXI.js WebGL ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ë¨');
            
            // ë¡œë”© í™”ë©´ ìˆ¨ê¹€
            document.getElementById('loading').style.display = 'none';
        }

        // PIXI.js íˆ´íŒ í‘œì‹œ
        function showTooltipPIXI(event, node) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <strong>${node.id}</strong><br>
                íƒ€ì…: ${node.type === 'contract' ? 'ê³„ì•½' : 'ìˆ˜í–‰ìš©ì—­'}<br>
                ì—°ê²°: ${node.connections || 0}ê°œ
            `;
            tooltip.style.left = event.data.global.x + 10 + 'px';
            tooltip.style.top = event.data.global.y - 10 + 'px';
            tooltip.style.display = 'block';
        }

        // PIXI.js ë…¸ë“œ ë“œë˜ê·¸ ì„¤ì •
        function setupNodeDrag(nodeGraphic, nodeData) {
            // ë“œë˜ê·¸ ìƒíƒœë¥¼ ë…¸ë“œ ê·¸ë˜í”½ì— ì €ì¥
            nodeGraphic._dragData = {
                isDragging: false,
                dragStartPos: null
            };
            
            nodeGraphic.on('pointerdown', (event) => {
                nodeGraphic._dragData.dragStartPos = { x: event.data.global.x, y: event.data.global.y };
                nodeGraphic._dragData.isDragging = false; // ì•„ì§ ë“œë˜ê·¸ ì‹œì‘ ì•ˆí•¨
                nodeGraphic.alpha = 0.8;
                if (!event.data.originalEvent.shiftKey) {
                    simulation.alphaTarget(0.1).restart(); // ë” ë¶€ë“œëŸ¬ìš´ ì¬ì‹œì‘
                }
            });
            
            nodeGraphic.on('pointermove', (event) => {
                const dragData = nodeGraphic._dragData;
                if (dragData.dragStartPos) {
                    const dx = event.data.global.x - dragData.dragStartPos.x;
                    const dy = event.data.global.y - dragData.dragStartPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 5í”½ì…€ ì´ìƒ ì›€ì§ì´ë©´ ë“œë˜ê·¸ë¡œ ì¸ì‹
                    if (distance > 5) {
                        dragData.isDragging = true;
                        console.log('ë“œë˜ê·¸ ì‹œì‘:', nodeData.id); // ë””ë²„ê¹…ìš©
                        
                        const position = event.data.getLocalPosition(viewport);
                        nodeData.fx = position.x;
                        nodeData.fy = position.y;
                    }
                }
            });
            
            nodeGraphic.on('pointerup', (event) => {
                const dragData = nodeGraphic._dragData;
                
                if (dragData.isDragging) {
                    // ë“œë˜ê·¸ ì¢…ë£Œ ì²˜ë¦¬
                    dragData.isDragging = false;
                    nodeGraphic.alpha = 1.0;
                    simulation.alphaTarget(0.01).alphaDecay(0.05); // ë¶€ë“œëŸ½ê²Œ ê°ì†
                    nodeData.fx = null;
                    nodeData.fy = null;
                    console.log('ë“œë˜ê·¸ ì¢…ë£Œ:', nodeData.id); // ë””ë²„ê¹…ìš©
                } else {
                    // í´ë¦­ ì²˜ë¦¬ (ë“œë˜ê·¸ê°€ ì•„ë‹ ë•Œë§Œ)
                    event.stopPropagation();
                    console.log('ğŸ–±ï¸ ë…¸ë“œ í´ë¦­ ê°ì§€:', nodeData.id, nodeData.type);
                    selectNode(nodeData);
                    console.log('âœ… selectNode í˜¸ì¶œ ì™„ë£Œ'); // ë””ë²„ê¹…ìš©
                }
                dragData.dragStartPos = null;
            });
            
            nodeGraphic.on('pointerupoutside', () => {
                const dragData = nodeGraphic._dragData;
                if (dragData.isDragging) {
                    dragData.isDragging = false;
                    nodeGraphic.alpha = 1.0;
                    if (!simulation.alphaTarget()) simulation.alphaTarget(0);
                    nodeData.fx = null;
                    nodeData.fy = null;
                }
                dragData.dragStartPos = null;
            });
        }

        // ë…¸ë“œ í¬ê¸° ê³„ì‚°
        function getNodeSize(d) {
            return Math.max(8, Math.min(8 + Math.sqrt(d.connections) * 2, 25));
        }

        // í…ìŠ¤íŠ¸ ìë¥´ê¸°
        function truncateText(text, maxLength) {
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
        }

        // ì¤Œ ë ˆë²¨ì— ë”°ë¥¸ ìŠ¤ë§ˆíŠ¸ í…ìŠ¤íŠ¸ í‘œì‹œ íŒë‹¨ (ë” ë§ì´ ë³´ì´ê²Œ ìˆ˜ì •)
        function shouldShowLabel(node, zoomLevel) {
            const connections = node.connections || 0;
            
            // ì¤Œ < 0.1: í…ìŠ¤íŠ¸ ì™„ì „ ìˆ¨ê¹€
            if (zoomLevel < 0.1) {
                return false;
            }
            
            // ì¤Œ 0.1-0.3: ì„œë¹„ìŠ¤ ë…¸ë“œì™€ ì£¼ìš” ê³„ì•½ ë…¸ë“œë§Œ í‘œì‹œ
            if (zoomLevel >= 0.1 && zoomLevel < 0.3) {
                return node.type === 'service' || connections >= 5;
            }
            
            // ì¤Œ 0.3-0.7: ë” ë§ì€ ë…¸ë“œ í‘œì‹œ
            if (zoomLevel >= 0.3 && zoomLevel < 0.7) {
                return node.type === 'service' || connections >= 2;
            }
            
            // ì¤Œ 0.7 ì´ìƒ: ê±°ì˜ ëª¨ë“  ë…¸ë“œ í‘œì‹œ
            return true;
        }

        // ì¤Œ ë ˆë²¨ì— ë”°ë¥¸ í…ìŠ¤íŠ¸ í¬ê¸° ì¡°ì •
        function getTextSizeForZoom(baseSize, zoomLevel) {
            if (zoomLevel > 2.0) {
                // ì¤Œ 2.0 ì´ìƒì¼ ë•Œ í…ìŠ¤íŠ¸ í¬ê¸° í™•ëŒ€
                return Math.min(baseSize * 1.5, baseSize * (zoomLevel * 0.5));
            }
            return baseSize;
        }

        // ëª¨ë“  ë¼ë²¨ì˜ í‘œì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateLabelsVisibility() {
            nodes.forEach(node => {
                const labelGraphic = nodeGraphics.get(`label_${node.id}`);
                if (labelGraphic) {
                    labelGraphic.visible = shouldShowLabel(node, currentScale);
                    
                    // ì¤Œ ë ˆë²¨ì— ë”°ë¥¸ í…ìŠ¤íŠ¸ í¬ê¸° ì¡°ì •
                    const newSize = getTextSizeForZoom(14, currentScale);
                    if (labelGraphic.style.fontSize !== newSize) {
                        labelGraphic.style.fontSize = newSize;
                    }
                }
            });
        }

        // ë…¸ë“œ í˜¸ë²„ íš¨ê³¼ (ì‹œê°ì  í”¼ë“œë°± í–¥ìƒ)
        function onNodeHover(nodeGraphic, node, isHovering) {
            const labelGraphic = nodeGraphics.get(`label_${node.id}`);
            
            if (isHovering) {
                // í˜¸ë²„ ì‹œì‘ - ë¶€ë“œëŸ¬ìš´ í™•ëŒ€ íš¨ê³¼
                gsap.to(nodeGraphic.scale, {
                    x: 1.2,
                    y: 1.2,
                    duration: 0.2,
                    ease: "power2.out"
                });
                
                // ë…¸ë“œ ê¸€ë¡œìš° íš¨ê³¼
                gsap.to(nodeGraphic, {
                    alpha: 0.9,
                    duration: 0.2
                });
                
                // í…ìŠ¤íŠ¸ ë¼ë²¨ ê°•ì¡°
                if (labelGraphic && labelGraphic.visible) {
                    gsap.to(labelGraphic.scale, {
                        x: 1.15,
                        y: 1.15,
                        duration: 0.2,
                        ease: "power2.out"
                    });
                    
                    // í…ìŠ¤íŠ¸ ìƒ‰ìƒ ê°•ì¡° - EAN ë¸Œëœë“œ ì»¬ëŸ¬
                    const originalFill = labelGraphic.style.fill;
                    labelGraphic._originalFill = originalFill;
                    labelGraphic.style.fill = node.type === 'service' ? EAN_COLORS.service_hover : EAN_COLORS.contract_hover; // EAN í˜¸ë²„ ìƒ‰ìƒ
                }
                
            } else {
                // í˜¸ë²„ ì¢…ë£Œ - ì›ë˜ ìƒíƒœë¡œ ë³µì›
                gsap.to(nodeGraphic.scale, {
                    x: 1.0,
                    y: 1.0,
                    duration: 0.2,
                    ease: "power2.out"
                });
                
                gsap.to(nodeGraphic, {
                    alpha: 1.0,
                    duration: 0.2
                });
                
                // í…ìŠ¤íŠ¸ ë¼ë²¨ ì›ë˜ í¬ê¸°ë¡œ ë³µì›
                if (labelGraphic && labelGraphic.visible) {
                    gsap.to(labelGraphic.scale, {
                        x: 1.0,
                        y: 1.0,
                        duration: 0.2,
                        ease: "power2.out"
                    });
                    
                    // í…ìŠ¤íŠ¸ ìƒ‰ìƒ ì›ë˜ëŒ€ë¡œ ë³µì›
                    if (labelGraphic._originalFill) {
                        labelGraphic.style.fill = labelGraphic._originalFill;
                    }
                }
            }
        }

        // í´ë¦­ ì‹œ ë…¸ë“œ í…ìŠ¤íŠ¸ í™•ì¥ ì‹œìŠ¤í…œ (ë°°ê²½ ë°•ìŠ¤ ì œê±°)
        function expandNodeText(labelGraphic, node) {
            if (!labelGraphic) return;
            
            // ì›ë˜ í…ìŠ¤íŠ¸ ì €ì¥
            const originalText = labelGraphic.text;
            const fullText = node.id; // í’€ í…ìŠ¤íŠ¸ (truncate ì—†ì´)
            
            // í…ìŠ¤íŠ¸ê°€ ì˜ë ¸ì„ ë•Œë§Œ í™•ì¥
            if (fullText.length > originalText.length) {
                // í’€ í…ìŠ¤íŠ¸ë¡œ ì—…ë°ì´íŠ¸
                labelGraphic.text = fullText;
                labelGraphic._isExpanded = true;
                labelGraphic._originalText = originalText;
            }
            
            // ì‹œê°ì  ê°•ì¡° íš¨ê³¼ (ë°°ê²½ ì—†ì´ í…ìŠ¤íŠ¸ë§Œ ê°•ì¡°)
            if (labelGraphic.visible) {
                // í…ìŠ¤íŠ¸ ê°•ì¡° ì• ë‹ˆë©”ì´ì…˜
                gsap.to(labelGraphic.scale, {
                    x: 1.15,
                    y: 1.15,
                    duration: 0.3,
                    ease: "back.out(1.7)"
                });
                
                gsap.to(labelGraphic, {
                    alpha: 1.0,
                    duration: 0.3
                });
                
                // í…ìŠ¤íŠ¸ ìƒ‰ìƒì„ ë¶‰ì€ìƒ‰ í•˜ì´ë¼ì´íŠ¸ë¡œ ë³€ê²½
                labelGraphic.style.fill = 0xff0000; // ë¶‰ì€ìƒ‰ í•˜ì´ë¼ì´íŠ¸
                labelGraphic.style.fontWeight = 'bold';
            }
        }

        // í…ìŠ¤íŠ¸ í™•ì¥ í•´ì œ (ì„ íƒ í•´ì œ ì‹œ)
        function restoreAllNodeTexts() {
            nodes.forEach(node => {
                const labelGraphic = nodeGraphics.get(`label_${node.id}`);
                if (labelGraphic && labelGraphic._isExpanded) {
                    // ì›ë˜ í…ìŠ¤íŠ¸ë¡œ ë³µì›
                    if (labelGraphic._originalText) {
                        labelGraphic.text = labelGraphic._originalText;
                    }
                    
                    // í…ìŠ¤íŠ¸ ìƒíƒœ ë³µì›
                    gsap.to(labelGraphic.scale, {
                        x: 1.0,
                        y: 1.0,
                        duration: 0.2
                    });
                    
                    gsap.to(labelGraphic, {
                        alpha: 1.0,
                        duration: 0.2
                    });
                    
                    // ì›ë˜ ìƒ‰ìƒ ë³µì› - EAN ë¸Œëœë“œ ìƒ‰ìƒ
                    labelGraphic.style.fill = node.type === 'service' ? EAN_COLORS.text_primary : EAN_COLORS.text_secondary;
                    labelGraphic.style.fontWeight = 'bold';
                    
                    // í”Œë˜ê·¸ ì œê±°
                    labelGraphic._isExpanded = false;
                    labelGraphic._originalText = null;
                }
            });
        }

        // ë„¤íŠ¸ì›Œí¬ ê²½ê³„ ê³„ì‚°
        function calculateNetworkBounds() {
            if (!nodes || nodes.length === 0) return null;
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            nodes.forEach(node => {
                if (node.x !== undefined && node.y !== undefined) {
                    minX = Math.min(minX, node.x);
                    maxX = Math.max(maxX, node.x);
                    minY = Math.min(minY, node.y);
                    maxY = Math.max(maxY, node.y);
                }
            });
            
            return {
                minX, maxX, minY, maxY,
                width: maxX - minX,
                height: maxY - minY,
                centerX: (minX + maxX) / 2,
                centerY: (minY + maxY) / 2
            };
        }

        // ì „ì²´ ë„¤íŠ¸ì›Œí¬ë¥¼ ë³´ê¸° ìœ„í•œ ìµœì  ì¤Œ ë ˆë²¨ ê³„ì‚°
        function getOptimalZoomTransform() {
            const bounds = calculateNetworkBounds();
            if (!bounds) return d3.zoomIdentity;
            
            // ì—¬ë°±ì„ ê³ ë ¤í•œ ìŠ¤ì¼€ì¼ ê³„ì‚° (í™”ë©´ì˜ 80% ì‚¬ìš©)
            const padding = 100;
            const scaleX = (width - padding * 2) / bounds.width;
            const scaleY = (height - padding * 2) / bounds.height;
            const scale = Math.min(scaleX, scaleY, 1); // ìµœëŒ€ 1ë°°ê¹Œì§€ë§Œ
            
            // ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ translate ê³„ì‚°
            const translateX = width / 2 - bounds.centerX * scale;
            const translateY = height / 2 - bounds.centerY * scale;
            
            return d3.zoomIdentity
                .translate(translateX, translateY)
                .scale(scale);
        }

        // ì „ì²´ ë³´ê¸°ë¡œ ë¦¬ì…‹
        // êµ¬ SVG resetToOptimalView() í•¨ìˆ˜ëŠ” resetToOptimalViewPIXI()ë¡œ êµì²´ë¨

        // ê¸°ë³¸ í•¨ìˆ˜ë“¤
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const rect = document.querySelector('.graph-container').getBoundingClientRect();
            
            tooltip.innerHTML = `
                <strong>${d.id}</strong><br>
                íƒ€ì…: ${d.type === 'contract' ? 'ê³„ì•½ëª…' : 'ìˆ˜í–‰ìš©ì—­'}<br>
                ì—°ê²°: ${d.connections}ê°œ
                ${d.year ? `<br>ì—°ë„: ${d.year}` : ''}
            `;
            
            tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
            tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'none';
        }

        function selectNode(targetNode) {
            console.log('ğŸ”¥ selectNode í•¨ìˆ˜ í˜¸ì¶œë¨:', targetNode.id, targetNode.type);
            selectedNode = targetNode;
            
            const connectedNodes = new Set([targetNode.id]);
            const connectedLinks = new Set();
            const connectedNodesList = [];
            
            links.forEach(link => {
                if (link.source.id === targetNode.id || link.target.id === targetNode.id) {
                    connectedNodes.add(link.source.id);
                    connectedNodes.add(link.target.id);
                    connectedLinks.add(link);
                    
                    // ì—°ê²°ëœ ë…¸ë“œë“¤ì„ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€ (ì„ íƒëœ ë…¸ë“œ ì œì™¸)
                    if (link.source.id !== targetNode.id) {
                        connectedNodesList.push(link.source);
                    }
                    if (link.target.id !== targetNode.id) {
                        connectedNodesList.push(link.target);
                    }
                }
            });

            // ë°©ì‚¬í˜• ì¬ë°°ì¹˜ëŠ” ì¼ì‹œì ìœ¼ë¡œ ë¹„í™œì„±í™” (ë„ˆë¬´ ê²©ë ¬í•œ ì›€ì§ì„ ë°©ì§€)
            // arrangeConnectedNodesRadially(targetNode, connectedNodesList);

            // PIXI.js ë…¸ë“œ í•˜ì´ë¼ì´íŠ¸ (ë…¸ë“œ ìƒ‰ìƒ ì§ì ‘ ë³€ê²½ìœ¼ë¡œ ëª…í™•í•œ ì‹œê°ì  êµ¬ë¶„)
            nodes.forEach(node => {
                const nodeGraphic = nodeGraphics.get(node.id);
                const labelGraphic = nodeGraphics.get(`label_${node.id}`);
                
                if (nodeGraphic) {
                    // ê¸°ì¡´ ê·¸ë˜í”½ì„ í´ë¦¬ì–´í•˜ê³  ìƒˆë¡œ ê·¸ë¦¬ê¸°
                    nodeGraphic.clear();
                    const radius = getNodeSize(node);
                    
                    if (node.id === targetNode.id) {
                        // ì„ íƒëœ ë…¸ë“œ: ì›ë³¸ ìƒ‰ìƒ ìœ ì§€í•˜ë˜ ë” ì§„í•˜ê²Œ
                        console.log('ğŸ¯ ì„ íƒëœ ë…¸ë“œ ê°•ì¡°:', node.id);
                        const fillColor = getNodeColor(node, 'selected');
                        nodeGraphic.beginFill(fillColor);
                        nodeGraphic.lineStyle(4, 0xff0000, 1.0); // ë¶‰ì€ìƒ‰ í…Œë‘ë¦¬ë¡œ í•˜ì´ë¼ì´íŠ¸
                        nodeGraphic.drawCircle(0, 0, radius + 3);
                        nodeGraphic.endFill();
                        nodeGraphic.alpha = 1.0;
                        nodeGraphic.scale.set(1.3); // 30% í¬ê²Œ
                        
                        // ì¸í„°ë™í‹°ë¸Œ ì†ì„± ë° ì´ë²¤íŠ¸ ì¬ì„¤ì •
                        nodeGraphic.interactive = true;
                        nodeGraphic.cursor = 'pointer';
                        nodeGraphic.userData = node;
                        
                        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¬ì„¤ì •
                        nodeGraphic.removeAllListeners();
                        nodeGraphic.on('pointerover', (event) => {
                            showTooltipPIXI(event, node);
                            onNodeHover(nodeGraphic, node, true);
                        });
                        nodeGraphic.on('pointerout', (event) => {
                            hideTooltip();
                            onNodeHover(nodeGraphic, node, false);
                        });
                        setupNodeDrag(nodeGraphic, node);
                        
                        // ì„ íƒëœ ë…¸ë“œ í…ìŠ¤íŠ¸ í™•ì¥ ë° ê°•ì¡°
                        expandNodeText(labelGraphic, node);
                        
                        console.log(`ì„ íƒëœ ë…¸ë“œ "${node.id}" ê³¨ë“œ ìƒ‰ìƒìœ¼ë¡œ ë³€ê²½ë¨`);
                        
                    } else if (connectedNodes.has(node.id)) {
                        // ì—°ê²°ëœ ë…¸ë“œ: ì›ë³¸ ìƒ‰ìƒ ìœ ì§€í•˜ë˜ ë¶‰ì€ í…Œë‘ë¦¬ ì¶”ê°€
                        console.log('ğŸŸ¢ ì—°ê²°ëœ ë…¸ë“œ ê°•ì¡°:', node.id);
                        const fillColor = getNodeColor(node, 'default');
                        nodeGraphic.beginFill(fillColor);
                        nodeGraphic.lineStyle(3, 0xff0000, 0.8); // ë¶‰ì€ìƒ‰ í…Œë‘ë¦¬ë¡œ í•˜ì´ë¼ì´íŠ¸
                        nodeGraphic.drawCircle(0, 0, radius + 1);
                        nodeGraphic.endFill();
                        nodeGraphic.alpha = 1.0;
                        nodeGraphic.scale.set(1.1); // 10% í¬ê²Œ
                        
                        // ì¸í„°ë™í‹°ë¸Œ ì†ì„± ë° ì´ë²¤íŠ¸ ì¬ì„¤ì •
                        nodeGraphic.interactive = true;
                        nodeGraphic.cursor = 'pointer';
                        nodeGraphic.userData = node;
                        
                        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¬ì„¤ì •
                        nodeGraphic.removeAllListeners();
                        nodeGraphic.on('pointerover', (event) => {
                            showTooltipPIXI(event, node);
                            onNodeHover(nodeGraphic, node, true);
                        });
                        nodeGraphic.on('pointerout', (event) => {
                            hideTooltip();
                            onNodeHover(nodeGraphic, node, false);
                        });
                        setupNodeDrag(nodeGraphic, node);
                        
                        // ì—°ê²°ëœ ë…¸ë“œ í…ìŠ¤íŠ¸ì—ë„ ë¶‰ì€ í•˜ì´ë¼ì´íŠ¸ ì ìš©
                        if (labelGraphic && labelGraphic.visible) {
                            gsap.to(labelGraphic, {
                                alpha: 1.0,
                                duration: 0.3
                            });
                            gsap.to(labelGraphic.scale, {
                                x: 1.1,
                                y: 1.1,
                                duration: 0.3
                            });
                            // ì—°ê²°ëœ ë…¸ë“œ í…ìŠ¤íŠ¸ë„ ë¶‰ì€ìƒ‰ìœ¼ë¡œ
                            labelGraphic.style.fill = 0xff0000; // ë¶‰ì€ìƒ‰ í•˜ì´ë¼ì´íŠ¸
                        }
                        
                        console.log(`ì—°ê²°ëœ ë…¸ë“œ "${node.id}" ê°•ì¡° ìƒ‰ìƒìœ¼ë¡œ ë³€ê²½ë¨`);
                        
                    } else {
                        // ê´€ë ¨ ì—†ëŠ” ë…¸ë“œ: ì›ë³¸ ìƒ‰ìƒì´ì§€ë§Œ ì•„ì£¼ íë¦¬ê²Œ
                        console.log('âš« ê´€ë ¨ì—†ëŠ” ë…¸ë“œ íë¦¬ê²Œ ì²˜ë¦¬:', node.id);
                        const fillColor = getNodeColor(node, 'default');
                        nodeGraphic.beginFill(fillColor);
                        nodeGraphic.lineStyle(1, 0xcccccc, 0.3);
                        nodeGraphic.drawCircle(0, 0, radius);
                        nodeGraphic.endFill();
                        nodeGraphic.alpha = 0.2; // ì•„ì£¼ íë¦¬ê²Œ (ë…¸ë“œ ìì²´ë¥¼ íë¦¬ê²Œ)
                        nodeGraphic.scale.set(0.8); // í¬ê¸°ë„ ì‘ê²Œ
                        
                        // ì¸í„°ë™í‹°ë¸Œ ì†ì„± ë° ì´ë²¤íŠ¸ ì¬ì„¤ì •
                        nodeGraphic.interactive = true;
                        nodeGraphic.cursor = 'pointer';
                        nodeGraphic.userData = node;
                        
                        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¬ì„¤ì •
                        nodeGraphic.removeAllListeners();
                        nodeGraphic.on('pointerover', (event) => {
                            showTooltipPIXI(event, node);
                            onNodeHover(nodeGraphic, node, true);
                        });
                        nodeGraphic.on('pointerout', (event) => {
                            hideTooltip();
                            onNodeHover(nodeGraphic, node, false);
                        });
                        setupNodeDrag(nodeGraphic, node);
                        
                        // ê´€ë ¨ ì—†ëŠ” ë…¸ë“œ í…ìŠ¤íŠ¸ë„ ë” íë¦¬ê²Œ (ìƒ‰ìƒë„ íšŒìƒ‰ìœ¼ë¡œ)
                        if (labelGraphic && labelGraphic.visible) {
                            gsap.to(labelGraphic, {
                                alpha: 0.3,
                                duration: 0.3
                            });
                            gsap.to(labelGraphic.scale, {
                                x: 0.9,
                                y: 0.9,
                                duration: 0.3
                            });
                            // ê´€ë ¨ ì—†ëŠ” í…ìŠ¤íŠ¸ëŠ” íšŒìƒ‰ìœ¼ë¡œ
                            labelGraphic.style.fill = 0x888888; // íšŒìƒ‰
                        }
                        
                        console.log(`ê´€ë ¨ ì—†ëŠ” ë…¸ë“œ "${node.id}" íšŒìƒ‰ìœ¼ë¡œ ë³€ê²½ë¨`);
                    }
                }
            });

            // PIXI.js ë§í¬ í•˜ì´ë¼ì´íŠ¸ - EAN ë¸Œëœë“œ ì»¬ëŸ¬
            links.forEach((link, index) => {
                const linkGraphic = linkGraphics.get(index);
                if (linkGraphic) {
                    if (connectedLinks.has(link)) {
                        linkGraphic.alpha = 1.0;
                        linkGraphic.tint = EAN_COLORS.link_highlighted; // EAN ê°•ì¡° ë§í¬ (ê·¸ë¦°)
                        // ì—°ê²°ëœ ë§í¬ë¥¼ ë” ë‘ê»ê²Œ í‘œì‹œ
                        linkGraphic.clear();
                        linkGraphic.lineStyle(
                            3, // ë‘ê»˜ ì¦ê°€
                            EAN_COLORS.link_highlighted, 
                            1.0 // ì™„ì „ ë¶ˆíˆ¬ëª…
                        );
                        linkGraphic.moveTo(link.source.x, link.source.y);
                        linkGraphic.lineTo(link.target.x, link.target.y);
                    } else {
                        linkGraphic.alpha = 0.08; // ë” íë¦¬ê²Œ
                        linkGraphic.tint = EAN_COLORS.text_muted; // EAN íë¦° ìƒ‰ìƒ
                    }
                }
            });

            document.getElementById('clearSelection').classList.add('visible');
            
            // ì„ íƒëœ ë…¸ë“œ ì •ë³´ í‘œì‹œ
            const selectedNodeInfo = document.getElementById('selectedNodeInfo');
            const selectedNodeName = document.getElementById('selectedNodeName');
            const relatedCountInfo = document.getElementById('relatedCountInfo');
            const relatedCount = document.getElementById('relatedCount');
            const linkCountInfo = document.getElementById('linkCountInfo');
            const linkCountElement = document.getElementById('linkCount');
            
            // ì„ íƒëœ ë…¸ë“œ ì´ë¦„ í‘œì‹œ (ìµœëŒ€ 20ì)
            const displayName = targetNode.id.length > 20 ? targetNode.id.substring(0, 20) + '...' : targetNode.id;
            selectedNodeName.textContent = displayName;
            selectedNodeInfo.style.display = 'block';
            
            // ì—°ê²°ëœ ë§í¬ ê°œìˆ˜ ê³„ì‚° ë° í‘œì‹œ
            const totalConnectedLinks = connectedLinks.size;
            linkCountElement.textContent = `${totalConnectedLinks}ê°œ`;
            linkCountInfo.style.display = 'block';
            
            // ê´€ë ¨ ë…¸ë“œ ê°œìˆ˜ í‘œì‹œ (ìˆ˜í–‰ìš©ì—­ ì„ íƒì‹œì—ë§Œ ê³„ì•½ ê°œìˆ˜ë¥¼ í‘œì‹œ)
            console.log('ì„ íƒëœ ë…¸ë“œ ì •ë³´:', {
                nodeId: targetNode.id,
                nodeType: targetNode.type,
                connectedNodesCount: connectedNodes.size,
                connectedLinksCount: connectedLinks.size,
                connectedNodesList: connectedNodesList.length
            });
            
            if (targetNode.type === 'service') {
                const relatedContracts = connectedNodesList.filter(node => node.type === 'contract').length;
                relatedCount.textContent = `${relatedContracts}ê°œ`;
                relatedCountInfo.querySelector('.stat-label').textContent = 'ê´€ë ¨ ê³„ì•½:';
                relatedCountInfo.style.display = 'block';
                
                console.log(`âœ… ìˆ˜í–‰ìš©ì—­ "${targetNode.id}" ì„ íƒ: ${relatedContracts}ê°œ ê³„ì•½, ${totalConnectedLinks}ê°œ ë§í¬ì™€ ì—°ê²°ë¨`);
                console.log('UI ìš”ì†Œ í‘œì‹œ ìƒíƒœ:', {
                    selectedNodeInfo: selectedNodeInfo.style.display,
                    relatedCountInfo: relatedCountInfo.style.display,
                    linkCountInfo: linkCountInfo.style.display
                });
            } else if (targetNode.type === 'contract') {
                const relatedServices = connectedNodesList.filter(node => node.type === 'service').length;
                relatedCount.textContent = `${relatedServices}ê°œ`;
                relatedCountInfo.querySelector('.stat-label').textContent = 'ê´€ë ¨ ìš©ì—­:';
                relatedCountInfo.style.display = 'block';
                
                console.log(`âœ… ê³„ì•½ëª… "${targetNode.id}" ì„ íƒ: ${relatedServices}ê°œ ìˆ˜í–‰ìš©ì—­, ${totalConnectedLinks}ê°œ ë§í¬ì™€ ì—°ê²°ë¨`);
                console.log('UI ìš”ì†Œ í‘œì‹œ ìƒíƒœ:', {
                    selectedNodeInfo: selectedNodeInfo.style.display,
                    relatedCountInfo: relatedCountInfo.style.display,
                    linkCountInfo: linkCountInfo.style.display
                });
            } else {
                relatedCountInfo.style.display = 'none';
                console.log('âŒ ì•Œ ìˆ˜ ì—†ëŠ” ë…¸ë“œ íƒ€ì…:', targetNode.type);
            }
            
            // ë…¸ë“œ ì„ íƒ ì‹œ ë¼ë²¨ ì—…ë°ì´íŠ¸ (ì¤Œ 1.5-2.5 ë ˆë²¨ì—ì„œ ì„ íƒëœ ë…¸ë“œ ì£¼ë³€ë§Œ í‘œì‹œ)
            updateLabelsVisibility();
        }

        // ì—°ê²°ëœ ë…¸ë“œë“¤ì„ ì„ íƒ ë…¸ë“œ ì¤‘ì‹¬ìœ¼ë¡œ ë°©ì‚¬í˜• ì¬ë°°ì¹˜
        function arrangeConnectedNodesRadially(centerNode, connectedNodes) {
            if (!connectedNodes || connectedNodes.length === 0) return;
            
            const centerX = centerNode.x;
            const centerY = centerNode.y;
            const radius = 60; // ë°©ì‚¬í˜• ë°°ì¹˜ ë°˜ì§€ë¦„ (120 â†’ 60ìœ¼ë¡œ ì ˆë°˜ ê°ì†Œ)
            const angleStep = (2 * Math.PI) / connectedNodes.length;
            
            connectedNodes.forEach((node, index) => {
                const angle = index * angleStep;
                
                // ë°©ì‚¬í˜• ìœ„ì¹˜ ê³„ì‚°
                const targetX = centerX + Math.cos(angle) * radius;
                const targetY = centerY + Math.sin(angle) * radius;
                
                // ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•´ forceë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë™
                node.fx = targetX;
                node.fy = targetY;
                
                // 0.5ì´ˆ í›„ì— ê³ ì • í•´ì œ (ìì—°ìŠ¤ëŸ¬ìš´ settling í—ˆìš©)
                setTimeout(() => {
                    if (node.fx === targetX && node.fy === targetY) {
                        node.fx = null;
                        node.fy = null;
                    }
                }, 500);
            });
            
            // ì‹œë®¬ë ˆì´ì…˜ ì¬ì‹œì‘í•˜ì—¬ ìƒˆë¡œìš´ ìœ„ì¹˜ë¡œ ì´ë™ (ë” ë¶€ë“œëŸ½ê²Œ)
            if (simulation) {
                simulation.alpha(0.1).restart(); // 0.3 â†’ 0.1ë¡œ ì¤„ì—¬ì„œ ë” ë¶€ë“œëŸ¬ìš´ ì´ë™
            }
        }

        function clearSelection() {
            selectedNode = null;
            selectedServices.clear();
            showSelectedOnly = false;
            
            // í…ìŠ¤íŠ¸ í™•ì¥ ìƒíƒœ ë³µì›
            restoreAllNodeTexts();
            
            // PIXI.js ë…¸ë“œ ìƒíƒœ ì´ˆê¸°í™” ë° ê³ ì • ìœ„ì¹˜ í•´ì œ
            nodes.forEach(node => {
                const nodeGraphic = nodeGraphics.get(node.id);
                const labelGraphic = nodeGraphics.get(`label_${node.id}`);
                
                if (nodeGraphic) {
                    // ë…¸ë“œë¥¼ ì›ë˜ ìƒ‰ìƒê³¼ ìƒíƒœë¡œ ë³µì›
                    nodeGraphic.clear();
                    const radius = getNodeSize(node);
                    const fillColor = getNodeColor(node, 'default');
                    
                    nodeGraphic.beginFill(fillColor);
                    nodeGraphic.lineStyle(2, EAN_COLORS.brand_white, 0.9);
                    nodeGraphic.drawCircle(0, 0, radius);
                    nodeGraphic.endFill();
                    nodeGraphic.alpha = 1.0;
                    nodeGraphic.visible = true;
                    nodeGraphic.scale.set(1.0); // ìŠ¤ì¼€ì¼ ì´ˆê¸°í™”
                    
                    // ì¸í„°ë™í‹°ë¸Œ ì†ì„± ë° ì´ë²¤íŠ¸ ì¬ì„¤ì •
                    nodeGraphic.interactive = true;
                    nodeGraphic.cursor = 'pointer';
                    nodeGraphic.userData = node;
                    
                    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¬ì„¤ì •
                    nodeGraphic.removeAllListeners();
                    nodeGraphic.on('pointerover', (event) => {
                        showTooltipPIXI(event, node);
                        onNodeHover(nodeGraphic, node, true);
                    });
                    nodeGraphic.on('pointerout', (event) => {
                        hideTooltip();
                        onNodeHover(nodeGraphic, node, false);
                    });
                    setupNodeDrag(nodeGraphic, node);
                }
                
                // ë¼ë²¨ ìƒíƒœë„ ì´ˆê¸°í™”
                if (labelGraphic && labelGraphic.visible) {
                    gsap.to(labelGraphic, {
                        alpha: 1.0,
                        duration: 0.2
                    });
                    gsap.to(labelGraphic.scale, {
                        x: 1.0,
                        y: 1.0,
                        duration: 0.2
                    });
                }
                
                // ê°•ì œë¡œ ê³ ì •ëœ ìœ„ì¹˜ í•´ì œ
                node.fx = null;
                node.fy = null;
            });

            // PIXI.js ë§í¬ ìƒíƒœ ì´ˆê¸°í™”
            links.forEach((link, index) => {
                const linkGraphic = linkGraphics.get(index);
                if (linkGraphic) {
                    linkGraphic.alpha = 0.4;
                    linkGraphic.tint = 0xffffff;
                    linkGraphic.visible = true;
                }
            });

            document.getElementById('clearSelection').classList.remove('visible');
            
            // ì„ íƒëœ ë…¸ë“œ ì •ë³´ ìˆ¨ê¸°ê¸°
            document.getElementById('selectedNodeInfo').style.display = 'none';
            document.getElementById('relatedCountInfo').style.display = 'none';
            document.getElementById('linkCountInfo').style.display = 'none';
            
            // ê´€ë ¨ ìš©ì—­ ë¼ë²¨ ì›ë˜ëŒ€ë¡œ ë³µì›
            document.getElementById('relatedCountInfo').querySelector('.stat-label').textContent = 'ê´€ë ¨ ê³„ì•½:';
            
            // ì„ íƒ í•´ì œ ì‹œ ë¼ë²¨ ì—…ë°ì´íŠ¸
            updateLabelsVisibility();
        }

        // ë“œë˜ê·¸ ì´ë²¤íŠ¸
        // SVG ë“œë˜ê·¸ í•¨ìˆ˜ë“¤ì€ PIXI.js setupNodeDrag()ë¡œ ì´ë™ë¨

        // PIXI.js ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupEventListeners() {
            // PIXI.js ì¤Œ ì»¨íŠ¸ë¡¤
            document.getElementById('zoomIn').addEventListener('click', () => {
                zoomInPIXI();
            });

            document.getElementById('zoomOut').addEventListener('click', () => {
                zoomOutPIXI();
            });

            document.getElementById('resetZoom').addEventListener('click', () => {
                resetToOptimalViewPIXI();
            });

            // ì„ íƒ í•´ì œ ë²„íŠ¼
            document.getElementById('clearSelection').addEventListener('click', () => {
                clearSelection();
            });
            
            // PIXI.js ê²€ìƒ‰ ê¸°ëŠ¥
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                searchNodesPIXI(searchTerm);
            });
        }

        // PIXI.js ì¤Œ ì¸ í•¨ìˆ˜
        function zoomInPIXI() {
            const scaleFactor = 1.2;
            const newScale = Math.min(4, currentScale * scaleFactor);
            if (newScale !== currentScale) {
                const centerX = width / 2;
                const centerY = height / 2;
                const worldPos = {
                    x: (centerX - viewport.position.x) / currentScale,
                    y: (centerY - viewport.position.y) / currentScale
                };
                
                currentScale = newScale;
                viewport.scale.set(currentScale);
                viewport.position.x = centerX - worldPos.x * currentScale;
                viewport.position.y = centerY - worldPos.y * currentScale;
                
                updateLabelsVisibility(); // ì¤Œ ë³€ê²½ ì‹œ ë¼ë²¨ ì—…ë°ì´íŠ¸
                console.log('ì¤Œ ì¸:', currentScale);
            }
        }

        // PIXI.js ì¤Œ ì•„ì›ƒ í•¨ìˆ˜
        function zoomOutPIXI() {
            const scaleFactor = 0.8;
            const newScale = Math.max(0.1, currentScale * scaleFactor);
            if (newScale !== currentScale) {
                const centerX = width / 2;
                const centerY = height / 2;
                const worldPos = {
                    x: (centerX - viewport.position.x) / currentScale,
                    y: (centerY - viewport.position.y) / currentScale
                };
                
                currentScale = newScale;
                viewport.scale.set(currentScale);
                viewport.position.x = centerX - worldPos.x * currentScale;
                viewport.position.y = centerY - worldPos.y * currentScale;
                
                updateLabelsVisibility(); // ì¤Œ ë³€ê²½ ì‹œ ë¼ë²¨ ì—…ë°ì´íŠ¸
                console.log('ì¤Œ ì•„ì›ƒ:', currentScale);
            }
        }

        // PIXI.js ìµœì  ë·° ë¦¬ì…‹ í•¨ìˆ˜
        function resetToOptimalViewPIXI() {
            // ë„¤íŠ¸ì›Œí¬ ê²½ê³„ ê³„ì‚°
            const bounds = calculateNetworkBounds();
            const padding = 50;
            const scaleX = (width - padding * 2) / bounds.width;
            const scaleY = (height - padding * 2) / bounds.height;
            const optimalScale = Math.min(scaleX, scaleY, 1); // ìµœëŒ€ 1ë°°ê¹Œì§€
            
            currentScale = optimalScale;
            viewport.scale.set(currentScale);
            
            // ì¤‘ì•™ ì •ë ¬
            const centerX = bounds.centerX * currentScale;
            const centerY = bounds.centerY * currentScale;
            viewport.position.x = width / 2 - centerX;
            viewport.position.y = height / 2 - centerY;
            
            updateLabelsVisibility(); // ì¤Œ ë³€ê²½ ì‹œ ë¼ë²¨ ì—…ë°ì´íŠ¸
            console.log('ë¦¬ì…‹ ì¤Œ:', currentScale);
        }

        // PIXI.js ë…¸ë“œ ê²€ìƒ‰ í•¨ìˆ˜
        function searchNodesPIXI(searchTerm) {
            if (searchTerm === '') {
                // ê²€ìƒ‰ì–´ê°€ ë¹„ì–´ìˆìœ¼ë©´ ëª¨ë“  ë…¸ë“œë¥¼ ê¸°ë³¸ ìƒíƒœë¡œ
                nodes.forEach(node => {
                    const nodeGraphic = nodeGraphics.get(node.id);
                    if (nodeGraphic) {
                        nodeGraphic.alpha = 1.0;
                        nodeGraphic.tint = EAN_COLORS.brand_white; // EAN ê¸°ë³¸ ìƒ‰ìƒ (ë¸Œëœë“œ í™”ì´íŠ¸)
                    }
                });
            } else {
                // ê²€ìƒ‰ ê²°ê³¼ í•˜ì´ë¼ì´íŠ¸
                nodes.forEach(node => {
                    const nodeGraphic = nodeGraphics.get(node.id);
                    if (nodeGraphic) {
                        if (node.id.toLowerCase().includes(searchTerm)) {
                            // ë§¤ì¹˜ë˜ëŠ” ë…¸ë“œ: EAN ê³¨ë“œ í•˜ì´ë¼ì´íŠ¸
                            nodeGraphic.alpha = 1.0;
                            nodeGraphic.tint = EAN_COLORS.accent_gold; // EAN ê³¨ë“œ í•˜ì´ë¼ì´íŠ¸
                        } else {
                            // ë§¤ì¹˜ë˜ì§€ ì•ŠëŠ” ë…¸ë“œ: íë¦¬ê²Œ
                            nodeGraphic.alpha = 0.3;
                            nodeGraphic.tint = EAN_COLORS.brand_white; // EAN ë¸Œëœë“œ í™”ì´íŠ¸
                        }
                    }
                });
            }
        }
        

        // PIXI.js í†µê³„ ì—…ë°ì´íŠ¸
        function updateStats() {
            let visibleNodeCount = 0;
            nodes.forEach(node => {
                const nodeGraphic = nodeGraphics.get(node.id);
                if (nodeGraphic && nodeGraphic.visible) {
                    visibleNodeCount++;
                }
            });
            
            document.getElementById('totalNodes').textContent = nodes.length.toLocaleString();
            document.getElementById('totalLinks').textContent = links.length.toLocaleString();
            document.getElementById('visibleNodes').textContent = visibleNodeCount.toLocaleString();
        }

        // íƒ€ì„ë¼ì¸ ë£°ëŸ¬ ì´ˆê¸°í™”
        function initializeTimelineRuler() {
            console.log('íƒ€ì„ë¼ì¸ ì´ˆê¸°í™”...');
            
            // ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ë„ ì¶”ì¶œ
            availableYears = [...new Set(allData.map(d => d.year))].sort();
            if (availableYears.length === 0) return;
            
            const startYear = Math.min(...availableYears);
            const endYear = Math.max(...availableYears);
            
            yearRange.min = startYear;
            yearRange.max = endYear;
            
            // ë“œë¡­ë‹¤ìš´ ì˜µì…˜ ìƒì„±
            const startYearSelect = document.getElementById('startYear');
            const endYearSelect = document.getElementById('endYear');
            
            // ê¸°ì¡´ ì˜µì…˜ ì œê±°
            startYearSelect.innerHTML = '';
            endYearSelect.innerHTML = '';
            
            // ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ë„ë¡œ ì˜µì…˜ ìƒì„±
            availableYears.forEach(year => {
                const startOption = document.createElement('option');
                startOption.value = year;
                startOption.textContent = year;
                if (year === startYear) startOption.selected = true;
                startYearSelect.appendChild(startOption);
                
                const endOption = document.createElement('option');
                endOption.value = year;
                endOption.textContent = year;
                if (year === endYear) endOption.selected = true;
                endYearSelect.appendChild(endOption);
            });
            
            // ë“œë¡­ë‹¤ìš´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            startYearSelect.addEventListener('change', (e) => {
                yearRange.min = parseInt(e.target.value);
                updateTimelineDisplay();
                filterDataByYear();
            });
            
            endYearSelect.addEventListener('change', (e) => {
                yearRange.max = parseInt(e.target.value);
                updateTimelineDisplay();
                filterDataByYear();
            });
            
            updateTimelineDisplay();
        }
        
        // ë…„ë„ í•„í„°ë§ í•¨ìˆ˜
        function filterDataByYear() {
            // ë…„ë„ ë²”ìœ„ì— ë”°ë¼ ë°ì´í„° í•„í„°ë§
            filteredData = allData.filter(d => d.year >= yearRange.min && d.year <= yearRange.max);
            createNetworkData();
            renderGraph();
            updateStats();
        }
        
        // íƒ€ì„ë¼ì¸ ë””ìŠ¤í”Œë ˆì´ ì—…ë°ì´íŠ¸
        function updateTimelineDisplay() {
            document.getElementById('timelineStart').textContent = yearRange.min;
            document.getElementById('timelineEnd').textContent = yearRange.max;
        }

        // ì„œë¹„ìŠ¤ ë¸Œë¼ìš°ì € ì´ˆê¸°í™”
        function initializeServiceBrowser() {
            console.log('ì„œë¹„ìŠ¤ ë¸Œë¼ìš°ì € ì´ˆê¸°í™”...');
            
            // ëª¨ë“  ì„œë¹„ìŠ¤ ì¶”ì¶œ
            allServices = [...new Set(allData.map(d => d.service))].sort();
            
            if (allServices.length === 0) {
                console.warn('ì„œë¹„ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤');
                return;
            }
            
            console.log(`ì„œë¹„ìŠ¤ ${allServices.length}ê°œ ë°œê²¬`);
            
            const serviceList = document.getElementById('serviceList');
            serviceList.innerHTML = '';
            
            allServices.forEach(service => {
                const serviceItem = document.createElement('div');
                serviceItem.className = 'service-item';
                serviceItem.innerHTML = `
                    <label class="service-label">
                        <input type="checkbox" class="service-checkbox" value="${service}">
                        <span class="service-name">${service}</span>
                    </label>
                `;
                serviceList.appendChild(serviceItem);
            });
            
            // ì„œë¹„ìŠ¤ ì„ íƒ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            serviceList.addEventListener('change', (e) => {
                if (e.target.classList.contains('service-checkbox')) {
                    const service = e.target.value;
                    if (e.target.checked) {
                        selectedServices.add(service);
                    } else {
                        selectedServices.delete(service);
                    }
                    updateServiceSelection();
                }
            });
            
            // ì„œë¹„ìŠ¤ ê²€ìƒ‰
            const serviceSearch = document.getElementById('serviceSearch');
            serviceSearch.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const serviceItems = serviceList.querySelectorAll('.service-item');
                
                serviceItems.forEach(item => {
                    const serviceName = item.querySelector('.service-name').textContent.toLowerCase();
                    item.style.display = serviceName.includes(searchTerm) ? 'block' : 'none';
                });
            });
            
            // ì„œë¹„ìŠ¤ ì»¨íŠ¸ë¡¤ ë²„íŠ¼
            document.getElementById('selectAllServices').addEventListener('click', () => {
                allServices.forEach(service => selectedServices.add(service));
                updateServiceCheckboxes();
                updateServiceSelection();
            });
            
            document.getElementById('clearAllServices').addEventListener('click', () => {
                selectedServices.clear();
                updateServiceCheckboxes();
                updateServiceSelection();
            });
            
            document.getElementById('showSelectedOnly').addEventListener('click', () => {
                showSelectedOnly = !showSelectedOnly;
                document.getElementById('showSelectedOnly').textContent = 
                    showSelectedOnly ? 'ì „ì²´ ë³´ê¸°' : 'ì„ íƒë§Œ ë³´ê¸°';
                updateServiceSelection();
            });
            
            updateServiceCount();
        }
        
        // ì„œë¹„ìŠ¤ ì²´í¬ë°•ìŠ¤ ì—…ë°ì´íŠ¸
        function updateServiceCheckboxes() {
            const checkboxes = document.querySelectorAll('.service-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectedServices.has(checkbox.value);
            });
        }
        
        // PIXI.js ì„œë¹„ìŠ¤ ì„ íƒ ì—…ë°ì´íŠ¸
        function updateServiceSelection() {
            if (selectedServices.size === 0 && !showSelectedOnly) {
                // ëª¨ë“  ë…¸ë“œì™€ ë§í¬ í‘œì‹œ
                nodes.forEach(node => {
                    const nodeGraphic = nodeGraphics.get(node.id);
                    if (nodeGraphic) {
                        nodeGraphic.visible = true;
                    }
                });
                
                links.forEach((link, index) => {
                    const linkGraphic = linkGraphics.get(index);
                    if (linkGraphic) {
                        linkGraphic.visible = true;
                    }
                });
            } else {
                // ì„ íƒëœ ì„œë¹„ìŠ¤ì™€ ê´€ë ¨ëœ ë…¸ë“œë§Œ í‘œì‹œ
                const visibleServiceNodes = new Set();
                const visibleContractNodes = new Set();
                const visibleLinks = new Set();
                
                // ì„ íƒëœ ì„œë¹„ìŠ¤ì™€ ì—°ê²°ëœ ê³„ì•½ ì°¾ê¸°
                links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    if (selectedServices.has(targetId)) {
                        visibleServiceNodes.add(targetId);
                        visibleContractNodes.add(sourceId);
                        visibleLinks.add(link);
                    }
                });
                
                // PIXI.js ë…¸ë“œ ê°€ì‹œì„± ì—…ë°ì´íŠ¸
                nodes.forEach(node => {
                    const nodeGraphic = nodeGraphics.get(node.id);
                    if (nodeGraphic) {
                        if (node.type === 'service') {
                            nodeGraphic.visible = visibleServiceNodes.has(node.id);
                        } else {
                            nodeGraphic.visible = visibleContractNodes.has(node.id);
                        }
                    }
                });
                
                // PIXI.js ë§í¬ ê°€ì‹œì„± ì—…ë°ì´íŠ¸
                links.forEach((link, index) => {
                    const linkGraphic = linkGraphics.get(index);
                    if (linkGraphic) {
                        linkGraphic.visible = visibleLinks.has(link);
                    }
                });
            }
            
            updateServiceCount();
            updateStats(); // ê°€ì‹œì„± ë³€ê²½ í›„ í†µê³„ ì—…ë°ì´íŠ¸
        }
        
        // ì„œë¹„ìŠ¤ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
        function updateServiceCount() {
            const selectedCount = selectedServices.size;
            const totalCount = allServices.length;
            document.getElementById('selectedServiceCount').textContent = `${selectedCount}/${totalCount}`;
        }
    </script>
</body>
</html>
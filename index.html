<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EAN 계약 네트워크</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="styles.css"></noscript>
    <style>
        /* 검색 하이라이트 스타일 */
        .node.search-match {
            stroke: #fbbf24 !important;
            stroke-width: 3px !important;
        }
        .node.search-dim {
            opacity: 0.3;
        }
        /* 노드 선택 스타일 */
        .node.highlighted {
            stroke: #ef4444 !important;
            stroke-width: 3px !important;
        }
        .node.blurred {
            opacity: 0.3;
        }
        .link.highlighted {
            stroke: #ef4444 !important;
            stroke-width: 3px !important;
        }
        .link.blurred {
            opacity: 0.2;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="graph-container">
            <!-- 로딩 화면 -->
            <div class="loading" id="loading">
                <div class="eco-spinner"></div>
                <div class="loading-text">
                    <span class="en-text">Connecting the network footprints of EAN</span><br>
                    <span class="en-sub-text">Architectural group in environmental, ecological, and energy fields</span><br>
                    <span class="en-wait">Please wait a moment</span><br><br>
                    <span class="ko-text">환경·생태·에너지 분야 건축인 그룹 EAN의</span><br>
                    <span class="ko-sub-text">네트워크 발자취를 연결하고 있습니다</span><br>
                    <span class="ko-wait">잠시만 기다려주세요</span>
                </div>
            </div>
            
            <!-- 플로팅 컨트롤 패널 -->
            <div class="floating-controls">
                <div class="control-group">
                    <label>검색</label>
                    <input type="text" class="search-input" id="searchInput" placeholder="계약명, 수행용역 검색..." style="width: 100%;">
                    <div class="zoom-controls-inline" style="justify-content: center; margin-top: 12px;">
                        <button class="zoom-btn" id="zoomIn">+</button>
                        <button class="zoom-btn" id="zoomOut">−</button>
                        <button class="zoom-btn" id="resetZoom">⌂</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>회사 연대기</label>
                    <div class="year-selector-container">
                        <div class="year-selector">
                            <div class="year-input-group">
                                <label for="startYear">시작:</label>
                                <select id="startYear" class="year-dropdown">
                                    <option value="2020">2020</option>
                                    <option value="2021">2021</option>
                                    <option value="2022">2022</option>
                                    <option value="2023">2023</option>
                                    <option value="2024">2024</option>
                                </select>
                            </div>
                            <div class="year-input-group">
                                <label for="endYear">끝:</label>
                                <select id="endYear" class="year-dropdown">
                                    <option value="2020">2020</option>
                                    <option value="2021">2021</option>
                                    <option value="2022">2022</option>
                                    <option value="2023">2023</option>
                                    <option value="2024" selected>2024</option>
                                </select>
                            </div>
                        </div>
                        <div class="timeline-display">
                            <div class="timeline-period">
                                <span class="period-label">EAN 여정</span>
                                <span class="period-range">
                                    <span id="timelineStart">2020</span>
                                    <span class="period-arrow">→</span>
                                    <span id="timelineEnd">2024</span>
                                </span>
                            </div>
                        </div>
                        
                        <div class="timeline-stats">
                            <div class="stat-item">
                                <span class="stat-label">총 노드:</span>
                                <span class="stat-value" id="totalNodes">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">연결:</span>
                                <span class="stat-value" id="totalLinks">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">표시된 노드:</span>
                                <span class="stat-value" id="visibleNodes">0</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="inline-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3b82f6;"></div>
                            <span>계약명</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #047857;"></div>
                            <span>수행용역</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 플로팅 오버레이 카드들 -->
            <div class="overlay-cards">
                <div class="overlay-card">
                    <h3>
                        수행용역
                        <span id="selectedServiceCount" style="font-size: 12px; color: #6b7280;">0/43</span>
                    </h3>
                    
                    <input type="text" class="service-search" id="serviceSearch" placeholder="수행용역 검색...">
                    
                    <div class="service-controls">
                        <button class="service-control-btn" id="selectAllServices">모두 선택</button>
                        <button class="service-control-btn" id="clearAllServices">모두 해제</button>
                        <button class="service-control-btn" id="showSelectedOnly">선택만 보기</button>
                    </div>
                    
                    <div class="service-list" id="serviceList">
                        <!-- 수행용역 리스트가 여기에 동적으로 생성됩니다 -->
                    </div>
                </div>
            </div>
            
            <button class="clear-selection" id="clearSelection">선택 해제</button>
            
            <svg id="graph"></svg>
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        // 전역 변수 (간소화)
        let allData = [];
        let filteredData = [];
        let nodes = [];
        let links = [];
        let simulation;
        let svg, g;
        let width, height;
        let zoom;
        let selectedNode = null;
        let currentScale = 1;
        let selectedServices = new Set();
        let allServices = [];
        let showSelectedOnly = false;
        let yearRange = { min: 2020, max: 2024 };
        let availableYears = [];
        let isSimulationRunning = false;

        // 색상 스키마 (수행용역 더 진한 녹색)
        const colors = {
            contract: '#3b82f6',
            service: '#047857'  // 연결선보다 더 진한 녹색
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await loadData();
                initGraph();
                setupEventListeners();
                updateStats();
            } catch (error) {
                console.error('초기화 오류:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ef4444;">❌ 데이터 로딩 실패</div>
                    <div style="font-size: 12px; margin-top: 10px;">JSON 데이터 파일을 확인해주세요.</div>
                `;
            }
        });

        // 데이터 로드 (JSON 전용)
        async function loadData() {
            try {
                console.log('JSON 데이터 로드 중...');
                const startTime = performance.now();
                
                const response = await fetch('data.json');
                if (!response.ok) {
                    throw new Error(`HTTP 오류: ${response.status} - ${response.statusText}`);
                }
                
                const jsonData = await response.json();
                console.log('JSON 구조 확인:', Object.keys(jsonData));
                
                if (!jsonData.records || !jsonData.lookup) {
                    throw new Error('JSON 구조 오류: records 또는 lookup 누락');
                }
                
                console.log(`JSON 로드 완료: ${jsonData.records.length.toLocaleString()}개 레코드`);
                
                allData = jsonData.records.map((record, index) => {
                    if (!record || record.length < 3) {
                        console.warn(`잘못된 레코드 ${index}:`, record);
                        return null;
                    }
                    
                    const [yearIdx, contractIdx, serviceIdx] = record;
                    const year = jsonData.lookup.years[yearIdx];
                    const contract = jsonData.lookup.contracts[contractIdx];
                    const service = jsonData.lookup.services[serviceIdx];
                    
                    if (!year || !contract || !service) {
                        console.warn(`매핑 실패 ${index}:`, {
                            yearIdx, year,
                            contractIdx, contract, 
                            serviceIdx, service
                        });
                        return null;
                    }
                    
                    return { year, contract, service };
                }).filter(item => item !== null);
                
                const endTime = performance.now();
                console.log(`JSON 파싱 완료: ${allData.length.toLocaleString()}개 항목 (${(endTime - startTime).toFixed(1)}ms)`);
                
                if (allData.length === 0) {
                    throw new Error('데이터 매핑 결과가 비어있음');
                }
                
                // 데이터 처리 완료
                filteredData = [...allData];
                createNetworkData();
                initializeTimelineRuler();
                initializeServiceBrowser();
                
            } catch (error) {
                console.error('JSON 데이터 로드 실패:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ef4444;">❌ JSON 데이터 로드 실패</div>
                    <div style="font-size: 12px; margin-top: 10px; color: #6b7280;">
                        오류: ${error.message}<br>
                        브라우저 콘솔(F12)에서 상세 오류를 확인하세요.
                    </div>
                `;
                throw error;
            }
        }

        // 네트워크 데이터 생성 (무결성 검증 강화)
        function createNetworkData() {
            console.log('네트워크 데이터 생성 시작...', filteredData.length, '개 항목');
            
            const nodeMap = new Map();
            const linkMap = new Map();
            let processedCount = 0;
            let errorCount = 0;

            filteredData.forEach((d, index) => {
                // 데이터 무결성 검증
                if (!d || typeof d.contract === 'undefined' || typeof d.service === 'undefined') {
                    console.warn(`잘못된 데이터 항목 ${index}:`, d);
                    errorCount++;
                    return;
                }
                
                if (!d.contract || d.contract === '' || !d.service || d.service === '') {
                    console.warn(`비어있는 데이터 ${index}:`, d);
                    errorCount++;
                    return;
                }
                
                // 계약명 노드
                const contractId = String(d.contract).trim();
                if (!nodeMap.has(contractId)) {
                    nodeMap.set(contractId, {
                        id: contractId,
                        type: 'contract',
                        year: d.year,
                        connections: 0
                    });
                }

                // 수행용역 노드
                const serviceId = String(d.service).trim();
                if (!nodeMap.has(serviceId)) {
                    nodeMap.set(serviceId, {
                        id: serviceId,
                        type: 'service',
                        connections: 0
                    });
                }

                // 링크 생성
                const linkId = `${contractId}|${serviceId}`;
                if (!linkMap.has(linkId)) {
                    linkMap.set(linkId, {
                        source: contractId,
                        target: serviceId,
                        weight: 1
                    });
                    nodeMap.get(contractId).connections++;
                    nodeMap.get(serviceId).connections++;
                } else {
                    linkMap.get(linkId).weight++;
                }
                
                processedCount++;
            });

            nodes = Array.from(nodeMap.values());
            links = Array.from(linkMap.values());
            
            const contractNodes = nodes.filter(n => n.type === 'contract').length;
            const serviceNodes = nodes.filter(n => n.type === 'service').length;
            
            console.log(`네트워크 데이터 생성 완료:`, {
                totalRecords: filteredData.length,
                processed: processedCount,
                errors: errorCount,
                totalNodes: nodes.length,
                contractNodes: contractNodes,
                serviceNodes: serviceNodes,
                links: links.length,
                expectedNodes: `계약 ${contractNodes} + 서비스 ${serviceNodes} = ${contractNodes + serviceNodes}`
            });
            
            // 무결성 검증 결과 출력
            if (errorCount > 0) {
                console.warn(`데이터 무결성 문제: ${errorCount}개 항목에서 오류 발견`);
            }
        }

        // 그래프 초기화 (간소화)
        function initGraph() {
            console.log('그래프 초기화...');
            
            const container = document.querySelector('.graph-container');
            width = container.clientWidth;
            height = container.clientHeight;

            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);

            g = svg.append('g');
            
            // 간단한 줌 설정
            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                    currentScale = event.transform.k;
                });

            svg.call(zoom);

            // 초기 줌 레벨을 0.4로 설정 (줌 아웃된 상태에서 시작)
            const initialZoom = d3.zoomIdentity.scale(0.2).translate(width * 1.95, height * 1.95);
            svg.call(zoom.transform, initialZoom);
            currentScale = 0.2;

            // 시뮬레이션 설정 (STARFIELD 계수 사용)
            simulation = d3.forceSimulation()
                .force('link', d3.forceLink().id(d => d.id).distance(180).strength(0.4))
                .force('charge', d3.forceManyBody().strength(-800).distanceMax(1000))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => getNodeSize(d) + 10));

            renderGraph();
        }

        // 그래프 렌더링 (간소화 및 고속화)
        function renderGraph() {
            console.log('렌더링 시작...', nodes.length, '개 노드,', links.length, '개 링크');
            
            if (!nodes || nodes.length === 0) {
                console.error('노드가 비어있음!');
                return;
            }
            
            g.selectAll('*').remove();

            // 링크 그리기
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.4)
                .attr('stroke-width', d => d.weight ? Math.sqrt(d.weight) + 1 : 1);

            // 노드 그리기
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('data-id', d => d.id)
                .attr('r', d => getNodeSize(d))
                .attr('fill', d => colors[d.type])
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .style('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip)
                .on('click', (event, d) => {
                    event.stopPropagation();
                    selectNode(d);
                });

            // 라벨 추가 (수행용역만)
            const label = g.append('g')
                .attr('class', 'labels')
                .selectAll('text')
                .data(nodes.filter(d => d.type === 'service'))
                .enter().append('text')
                .attr('class', 'node-label')
                .attr('text-anchor', 'middle')
                .style('font-size', '10px')
                .style('fill', '#333')
                .style('pointer-events', 'none')
                .text(d => truncateText(d.id, 15));

            console.log('렌더링 완료:', {
                linkElements: link.size(),
                nodeElements: node.size(), 
                labelElements: label.size()
            });

            // 배경 클릭 시 선택 해제
            svg.on('click', () => {
                clearSelection();
            });

            // 시뮬레이션 설정
            simulation.nodes(nodes);
            simulation.force('link').links(links);

            // 간단한 tick 함수
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + getNodeSize(d) + 12);
            });

            // 시뮬레이션 시작
            simulation.alpha(1).restart();
            isSimulationRunning = true;
            console.log('시뮬레이션 시작됨');
            
            // 로딩 화면 숨김
            document.getElementById('loading').style.display = 'none';
        }

        // 노드 크기 계산
        function getNodeSize(d) {
            return Math.max(8, Math.min(8 + Math.sqrt(d.connections) * 2, 25));
        }

        // 텍스트 자르기
        function truncateText(text, maxLength) {
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
        }

        // 네트워크 경계 계산
        function calculateNetworkBounds() {
            if (!nodes || nodes.length === 0) return null;
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            nodes.forEach(node => {
                if (node.x !== undefined && node.y !== undefined) {
                    minX = Math.min(minX, node.x);
                    maxX = Math.max(maxX, node.x);
                    minY = Math.min(minY, node.y);
                    maxY = Math.max(maxY, node.y);
                }
            });
            
            return {
                minX, maxX, minY, maxY,
                width: maxX - minX,
                height: maxY - minY,
                centerX: (minX + maxX) / 2,
                centerY: (minY + maxY) / 2
            };
        }

        // 전체 네트워크를 보기 위한 최적 줌 레벨 계산
        function getOptimalZoomTransform() {
            const bounds = calculateNetworkBounds();
            if (!bounds) return d3.zoomIdentity;
            
            // 여백을 고려한 스케일 계산 (화면의 80% 사용)
            const padding = 100;
            const scaleX = (width - padding * 2) / bounds.width;
            const scaleY = (height - padding * 2) / bounds.height;
            const scale = Math.min(scaleX, scaleY, 1); // 최대 1배까지만
            
            // 중앙 정렬을 위한 translate 계산
            const translateX = width / 2 - bounds.centerX * scale;
            const translateY = height / 2 - bounds.centerY * scale;
            
            return d3.zoomIdentity
                .translate(translateX, translateY)
                .scale(scale);
        }

        // 전체 보기로 리셋
        function resetToOptimalView() {
            const optimalTransform = getOptimalZoomTransform();
            svg.transition()
                .duration(750)
                .ease(d3.easeQuadOut)
                .call(zoom.transform, optimalTransform);
        }

        // 나머지 함수들은 기존과 동일하게 유지...
        // (타임라인, 서비스 브라우저, 이벤트 리스너 등은 기존 코드 사용)

        // 기본 함수들
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const rect = document.querySelector('.graph-container').getBoundingClientRect();
            
            tooltip.innerHTML = `
                <strong>${d.id}</strong><br>
                타입: ${d.type === 'contract' ? '계약명' : '수행용역'}<br>
                연결: ${d.connections}개
                ${d.year ? `<br>연도: ${d.year}` : ''}
            `;
            
            tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
            tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function selectNode(targetNode) {
            selectedNode = targetNode;
            
            const connectedNodes = new Set([targetNode.id]);
            const connectedLinks = new Set();
            
            links.forEach(link => {
                if (link.source.id === targetNode.id || link.target.id === targetNode.id) {
                    connectedNodes.add(link.source.id);
                    connectedNodes.add(link.target.id);
                    connectedLinks.add(link);
                }
            });

            g.selectAll('.node')
                .classed('blurred', d => !connectedNodes.has(d.id))
                .classed('highlighted', d => connectedNodes.has(d.id));

            g.selectAll('.link')
                .classed('blurred', d => !connectedLinks.has(d))
                .classed('highlighted', d => connectedLinks.has(d));

            document.getElementById('clearSelection').classList.add('visible');
        }

        function clearSelection() {
            selectedNode = null;
            selectedServices.clear();
            showSelectedOnly = false;
            
            g.selectAll('.node')
                .classed('blurred', false)
                .classed('highlighted', false)
                .style('display', null);

            g.selectAll('.link')
                .classed('blurred', false)
                .classed('highlighted', false)
                .style('display', null);

            document.getElementById('clearSelection').classList.remove('visible');
        }

        // 드래그 이벤트
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            // 줌 컨트롤
            document.getElementById('zoomIn').addEventListener('click', () => {
                svg.transition().duration(300).call(zoom.scaleBy, 1.2);
            });

            document.getElementById('zoomOut').addEventListener('click', () => {
                svg.transition().duration(300).call(zoom.scaleBy, 0.8);
            });

            document.getElementById('resetZoom').addEventListener('click', () => {
                resetToOptimalView();
            });

            // 선택 해제 버튼
            document.getElementById('clearSelection').addEventListener('click', () => {
                clearSelection();
            });
            
            // 검색 기능
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                
                if (searchTerm === '') {
                    // 검색어가 비어있으면 모든 노드 표시
                    g.selectAll('.node')
                        .classed('search-match', false)
                        .classed('search-dim', false);
                } else {
                    // 검색 결과 하이라이트
                    g.selectAll('.node')
                        .classed('search-match', d => d.id.toLowerCase().includes(searchTerm))
                        .classed('search-dim', d => !d.id.toLowerCase().includes(searchTerm));
                }
            });
            
        }
        

        // 통계 업데이트
        function updateStats() {
            const visibleNodeCount = g.selectAll('.node').nodes().filter(node => {
                return d3.select(node).style('display') !== 'none';
            }).length;
            
            document.getElementById('totalNodes').textContent = nodes.length.toLocaleString();
            document.getElementById('totalLinks').textContent = links.length.toLocaleString();
            document.getElementById('visibleNodes').textContent = visibleNodeCount.toLocaleString();
        }

        // 타임라인 룰러 초기화
        function initializeTimelineRuler() {
            console.log('타임라인 초기화...');
            
            // 사용 가능한 연도 추출
            availableYears = [...new Set(allData.map(d => d.year))].sort();
            if (availableYears.length === 0) return;
            
            const startYear = Math.min(...availableYears);
            const endYear = Math.max(...availableYears);
            
            yearRange.min = startYear;
            yearRange.max = endYear;
            
            // 드롭다운 옵션 생성
            const startYearSelect = document.getElementById('startYear');
            const endYearSelect = document.getElementById('endYear');
            
            // 기존 옵션 제거
            startYearSelect.innerHTML = '';
            endYearSelect.innerHTML = '';
            
            // 사용 가능한 연도로 옵션 생성
            availableYears.forEach(year => {
                const startOption = document.createElement('option');
                startOption.value = year;
                startOption.textContent = year;
                if (year === startYear) startOption.selected = true;
                startYearSelect.appendChild(startOption);
                
                const endOption = document.createElement('option');
                endOption.value = year;
                endOption.textContent = year;
                if (year === endYear) endOption.selected = true;
                endYearSelect.appendChild(endOption);
            });
            
            // 드롭다운 이벤트 리스너 추가
            startYearSelect.addEventListener('change', (e) => {
                yearRange.min = parseInt(e.target.value);
                updateTimelineDisplay();
                filterDataByYear();
            });
            
            endYearSelect.addEventListener('change', (e) => {
                yearRange.max = parseInt(e.target.value);
                updateTimelineDisplay();
                filterDataByYear();
            });
            
            updateTimelineDisplay();
        }
        
        // 년도 필터링 함수
        function filterDataByYear() {
            // 년도 범위에 따라 데이터 필터링
            filteredData = allData.filter(d => d.year >= yearRange.min && d.year <= yearRange.max);
            createNetworkData();
            renderGraph();
            updateStats();
        }
        
        // 타임라인 디스플레이 업데이트
        function updateTimelineDisplay() {
            document.getElementById('timelineStart').textContent = yearRange.min;
            document.getElementById('timelineEnd').textContent = yearRange.max;
        }

        // 서비스 브라우저 초기화
        function initializeServiceBrowser() {
            console.log('서비스 브라우저 초기화...');
            
            // 모든 서비스 추출
            allServices = [...new Set(allData.map(d => d.service))].sort();
            
            if (allServices.length === 0) {
                console.warn('서비스가 없습니다');
                return;
            }
            
            console.log(`서비스 ${allServices.length}개 발견`);
            
            const serviceList = document.getElementById('serviceList');
            serviceList.innerHTML = '';
            
            allServices.forEach(service => {
                const serviceItem = document.createElement('div');
                serviceItem.className = 'service-item';
                serviceItem.innerHTML = `
                    <label class="service-label">
                        <input type="checkbox" class="service-checkbox" value="${service}">
                        <span class="service-name">${service}</span>
                    </label>
                `;
                serviceList.appendChild(serviceItem);
            });
            
            // 서비스 선택 이벤트 리스너
            serviceList.addEventListener('change', (e) => {
                if (e.target.classList.contains('service-checkbox')) {
                    const service = e.target.value;
                    if (e.target.checked) {
                        selectedServices.add(service);
                    } else {
                        selectedServices.delete(service);
                    }
                    updateServiceSelection();
                }
            });
            
            // 서비스 검색
            const serviceSearch = document.getElementById('serviceSearch');
            serviceSearch.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const serviceItems = serviceList.querySelectorAll('.service-item');
                
                serviceItems.forEach(item => {
                    const serviceName = item.querySelector('.service-name').textContent.toLowerCase();
                    item.style.display = serviceName.includes(searchTerm) ? 'block' : 'none';
                });
            });
            
            // 서비스 컨트롤 버튼
            document.getElementById('selectAllServices').addEventListener('click', () => {
                allServices.forEach(service => selectedServices.add(service));
                updateServiceCheckboxes();
                updateServiceSelection();
            });
            
            document.getElementById('clearAllServices').addEventListener('click', () => {
                selectedServices.clear();
                updateServiceCheckboxes();
                updateServiceSelection();
            });
            
            document.getElementById('showSelectedOnly').addEventListener('click', () => {
                showSelectedOnly = !showSelectedOnly;
                document.getElementById('showSelectedOnly').textContent = 
                    showSelectedOnly ? '전체 보기' : '선택만 보기';
                updateServiceSelection();
            });
            
            updateServiceCount();
        }
        
        // 서비스 체크박스 업데이트
        function updateServiceCheckboxes() {
            const checkboxes = document.querySelectorAll('.service-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectedServices.has(checkbox.value);
            });
        }
        
        // 서비스 선택 업데이트
        function updateServiceSelection() {
            if (selectedServices.size === 0 && !showSelectedOnly) {
                // 모든 노드 표시
                g.selectAll('.node').style('display', null);
                g.selectAll('.link').style('display', null);
            } else {
                // 선택된 서비스와 관련된 노드만 표시
                const visibleServiceNodes = new Set();
                const visibleContractNodes = new Set();
                const visibleLinks = new Set();
                
                // 선택된 서비스와 연결된 계약 찾기
                links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    if (selectedServices.has(targetId)) {
                        visibleServiceNodes.add(targetId);
                        visibleContractNodes.add(sourceId);
                        visibleLinks.add(link);
                    }
                });
                
                g.selectAll('.node')
                    .style('display', d => {
                        if (d.type === 'service') {
                            return visibleServiceNodes.has(d.id) ? null : 'none';
                        } else {
                            return visibleContractNodes.has(d.id) ? null : 'none';
                        }
                    });
                    
                g.selectAll('.link')
                    .style('display', d => visibleLinks.has(d) ? null : 'none');
            }
            
            updateServiceCount();
        }
        
        // 서비스 카운트 업데이트
        function updateServiceCount() {
            const selectedCount = selectedServices.size;
            const totalCount = allServices.length;
            document.getElementById('selectedServiceCount').textContent = `${selectedCount}/${totalCount}`;
        }
    </script>
</body>
</html>

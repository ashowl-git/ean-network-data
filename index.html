<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>EAN 계약 네트워크</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>

<link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="styles.css"></noscript>

</head>
<body>
    <div class="container">
        
        <div class="graph-container">
            <div class="loading" id="loading">
                <div class="eco-spinner"></div>
                <div class="loading-text">
                    <span class="en-text">Connecting the network footprints of EAN</span><br>
                    <span class="en-sub-text">Architectural group in environmental, ecological, and energy fields</span><br>
                    <span class="en-wait">Please wait a moment</span><br><br>
                    <span class="ko-text">환경·생태·에너지 분야 건축인 그룹 EAN의</span><br>
                    <span class="ko-sub-text">네트워크 발자취를 연결하고 있습니다</span><br>
                    <span class="ko-wait">잠시만 기다려주세요</span>
                </div>
            </div>
            
            <!-- 플로팅 컨트롤 패널 -->
            <div class="floating-controls">
                <div class="control-group">
                    <label>검색</label>
                    <div style="display: flex; gap: 8px; align-items: flex-end;">
                        <input type="text" class="search-input" id="searchInput" placeholder="계약명, 수행용역 검색..." style="flex: 1;">
                        <div class="zoom-controls-inline">
                            <button class="zoom-btn" id="zoomIn">+</button>
                            <button class="zoom-btn" id="zoomOut">−</button>
                            <button class="zoom-btn" id="resetZoom">⌂</button>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>회사 연대기</label>
                    <div class="timeline-ruler-container">
                        <div class="timeline-ruler">
                            <div class="ruler-track"></div>
                            <div class="ruler-ticks"></div>
                            <div class="ruler-labels"></div>
                            <div class="selection-range">
                                <div class="range-handle range-start" data-year="2020"></div>
                                <div class="range-handle range-end" data-year="2024"></div>
                                <div class="range-fill"></div>
                            </div>
                        </div>
                        <div class="timeline-display">
                            <div class="timeline-period">
                                <span class="period-label">EAN 여정</span>
                                <span class="period-range">
                                    <span id="timelineStart">2020</span>
                                    <span class="period-arrow">→</span>
                                    <span id="timelineEnd">2024</span>
                                </span>
                            </div>
                        </div>
                        
                        <!-- 통계 정보 추가 -->
                        <div class="timeline-stats">
                            <div class="stat-item">
                                <span class="stat-label">총 노드:</span>
                                <span class="stat-value" id="totalNodes">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">연결:</span>
                                <span class="stat-value" id="totalLinks">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">표시된 노드:</span>
                                <span class="stat-value" id="visibleNodes">0</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>노드 타입</label>
                    <div class="filter-buttons" id="nodeTypeFilters">
                        <button class="filter-btn active" data-type="all">전체</button>
                        <button class="filter-btn" data-type="contract-only">계약명만</button>
                        <button class="filter-btn" data-type="service-only">수행용역만</button>
                    </div>
                    
                    <!-- 범례 이동 -->
                    <div class="inline-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3b82f6;"></div>
                            <span>계약명</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #10b981;"></div>
                            <span>수행용역</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 플로팅 오버레이 카드들 -->
            <div class="overlay-cards">
                <div class="overlay-card">
                    <h3>
                        수행용역
                        <span id="selectedServiceCount" style="font-size: 12px; color: #6b7280;">0/43</span>
                    </h3>
                    
                    <input type="text" class="service-search" id="serviceSearch" placeholder="수행용역 검색...">
                    
                    <div class="service-controls">
                        <button class="service-control-btn" id="selectAllServices">모두 선택</button>
                        <button class="service-control-btn" id="clearAllServices">모두 해제</button>
                        <button class="service-control-btn" id="showSelectedOnly">선택만 보기</button>
                    </div>
                    
                    <div class="service-list" id="serviceList">
                        <!-- 수행용역 리스트가 여기에 동적으로 생성됩니다 -->
                    </div>
                </div>
                
                <!-- 범례는 노드타입 하단으로 이동됨 -->
                
            </div>
            
            <!-- 줌 컨트롤은 검색 입력창 옆으로 이동됨 -->
            
            <button class="clear-selection" id="clearSelection">선택 해제</button>
            
            <svg id="graph"></svg>
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        // 전역 변수
        let allData = [];
        let filteredData = [];
        let nodes = [];
        let links = [];
        let simulation;
        let svg, g;
        let width, height;
        let zoom;
        let selectedNode = null;
        let currentScale = 1;
        let selectedServices = new Set();
        let allServices = [];
        let showSelectedOnly = false;
        let yearRange = { min: 2020, max: 2024 };
        let availableYears = [];

        // 성능 최적화 변수
        let isSimulationRunning = false;
        let animationFrameId = null;
        let lastUpdateTime = 0;
        let visibleNodes = [];
        let visibleLinks = [];
        let nodeQuadTree = null;
        let performanceMode = false;
        let smartPerformanceMode = false; // 지능형 성능 모드

        // 색상 스키마 (눈의 피로 감소를 위한 부드러운 색상)
        const colors = {
            contract: '#3b82f6',    // 파란색 - 계약명
            service: '#10b981'      // 초록색 - 수행용역
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await loadData();
                initGraph();
                setupEventListeners();
                updateStats();
            } catch (error) {
                console.error('초기화 오류:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ef4444;">❌ 데이터 로딩 실패</div>
                    <div style="font-size: 12px; margin-top: 10px;">CSV 파일을 확인해주세요.</div>
                `;
            }
        });

        // 최적화된 데이터 로드 (JSON 우선, CSV 폴백)
        async function loadData() {
            try {
                // JSON 파일 로드 시도
                console.log('JSON 데이터 로드 중...');
                const startTime = performance.now();
                
                const response = await fetch('./data.json');
                const jsonData = await response.json();
                
                console.log(`JSON 로드 완료: ${jsonData.records.length.toLocaleString()}개 레코드`);
                
                // 인덱스를 실제 값으로 변환
                allData = jsonData.records.map(record => ({
                    year: jsonData.lookup.years[record[0]],
                    contract: jsonData.lookup.contracts[record[1]], 
                    service: jsonData.lookup.services[record[2]]
                }));
                
                const endTime = performance.now();
                console.log(`JSON 파싱 완료: ${allData.length.toLocaleString()}개 항목 (${(endTime - startTime).toFixed(1)}ms)`);
                
            } catch (error) {
                console.warn('JSON 로드 실패, CSV로 폴백:', error);
                // CSV 폴백
                await loadDataCSV();
            }

            filteredData = [...allData];
            createNetworkData();
            
            // 타임라인 룰러 초기화
            initializeTimelineRuler();
            
            // 수행용역 브라우저 초기화
            initializeServiceBrowser();
        }

        // CSV 폴백 함수
        async function loadDataCSV() {
            console.log('CSV 데이터 로드 중...');
            const startTime = performance.now();
            
            const response = await fetch('./data.json');
            const text = await response.text();
            
            // CSV 파싱
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',');
            
            allData = lines.slice(1).map(line => {
                const values = parseCSVLine(line);
                return {
                    year: values[0]?.trim() || '',
                    contract: values[1]?.trim() || '',
                    service: values[2]?.trim() || ''
                };
            }).filter(d => d.year && d.contract && d.service);

            const endTime = performance.now();
            console.log(`CSV 파싱 완료: ${allData.length.toLocaleString()}개 항목 (${(endTime - startTime).toFixed(1)}ms)`);
        }

        // CSV 라인 파싱 (따옴표 처리)
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            
            return result;
        }

        // 네트워크 데이터 생성 (발주처 제거됨)
        function createNetworkData() {
            const nodeMap = new Map();
            const linkMap = new Map();

            // 노드 생성
            filteredData.forEach(d => {
                // 계약명 노드
                if (!nodeMap.has(d.contract)) {
                    nodeMap.set(d.contract, {
                        id: d.contract,
                        type: 'contract',
                        year: d.year,
                        connections: 0
                    });
                }

                // 수행용역 노드
                if (!nodeMap.has(d.service)) {
                    nodeMap.set(d.service, {
                        id: d.service,
                        type: 'service',
                        connections: 0
                    });
                }

                // 링크 생성 (계약명 - 수행용역만)
                const linkId = d.contract < d.service ? `${d.contract}|${d.service}` : `${d.service}|${d.contract}`;
                if (!linkMap.has(linkId)) {
                    linkMap.set(linkId, {
                        source: d.contract,
                        target: d.service,
                        weight: 1
                    });
                    nodeMap.get(d.contract).connections++;
                    nodeMap.get(d.service).connections++;
                } else {
                    linkMap.get(linkId).weight++;
                }
            });

            nodes = Array.from(nodeMap.values());
            links = Array.from(linkMap.values());
        }

        // 타임라인 룰러 초기화
        function initializeTimelineRuler() {
            const years = [...new Set(allData.map(d => parseInt(d.year)))].filter(y => !isNaN(y)).sort((a, b) => a - b);
            availableYears = years;
            
            if (years.length === 0) return;
            
            const minYear = Math.min(...years);
            const maxYear = Math.max(...years);
            
            // 전역 변수 업데이트
            yearRange.min = minYear;
            yearRange.max = maxYear;
            
            // 룰러 렌더링
            setTimeout(() => renderTimelineRuler(minYear, maxYear), 100);
            
            // 디스플레이 업데이트
            updateTimelineDisplay();
        }
        
        function renderTimelineRuler(minYear, maxYear) {
            const ticksContainer = document.querySelector('.ruler-ticks');
            const labelsContainer = document.querySelector('.ruler-labels');
            
            if (!ticksContainer || !labelsContainer) return;
            
            // 기존 요소 제거
            ticksContainer.innerHTML = '';
            labelsContainer.innerHTML = '';
            
            const totalYears = maxYear - minYear;
            
            // 주요 눈금만 생성 (시작, 중간점들, 끝)
            const majorYears = [minYear];
            const yearStep = Math.max(1, Math.floor(totalYears / 4)); // 최대 5개 구간
            for (let i = 1; i < 4; i++) {
                const year = minYear + (yearStep * i);
                if (year < maxYear) majorYears.push(year);
            }
            if (maxYear !== minYear) majorYears.push(maxYear);
            
            // 주요 눈금 생성
            majorYears.forEach(year => {
                const position = totalYears === 0 ? 50 : ((year - minYear) / totalYears) * 100;
                
                const tick = document.createElement('div');
                tick.className = 'ruler-tick major';
                tick.style.left = `${position}%`;
                ticksContainer.appendChild(tick);
            });
            
            // 선택 범위 업데이트 (라벨은 여기서 생성)
            updateRangeSelection(minYear, maxYear, minYear, maxYear);
        }
        
        function updateRangeSelection(minYear, maxYear, startYear, endYear) {
            const totalYears = maxYear - minYear;
            const startPos = totalYears === 0 ? 0 : ((startYear - minYear) / totalYears) * 100;
            const endPos = totalYears === 0 ? 100 : ((endYear - minYear) / totalYears) * 100;
            
            const startHandle = document.querySelector('.range-start');
            const endHandle = document.querySelector('.range-end');
            const rangeFill = document.querySelector('.range-fill');
            const labelsContainer = document.querySelector('.ruler-labels');
            
            if (startHandle && endHandle && rangeFill) {
                startHandle.style.left = `${startPos}%`;
                endHandle.style.left = `${endPos}%`;
                startHandle.dataset.year = startYear;
                endHandle.dataset.year = endYear;
                
                rangeFill.style.left = `${startPos}%`;
                rangeFill.style.width = `${Math.max(1, endPos - startPos)}%`;
            }
            
            // 기존 라벨 제거 후 선택된 시작/끝 연도만 표시
            if (labelsContainer) {
                labelsContainer.innerHTML = '';
                
                // 시작 연도 라벨
                const startLabel = document.createElement('div');
                startLabel.className = 'ruler-year selected';
                startLabel.textContent = startYear;
                startLabel.style.left = `${startPos}%`;
                startLabel.dataset.year = startYear;
                labelsContainer.appendChild(startLabel);
                
                // 끝 연도 라벨 (시작과 다른 경우만)
                if (startYear !== endYear) {
                    const endLabel = document.createElement('div');
                    endLabel.className = 'ruler-year selected';
                    endLabel.textContent = endYear;
                    endLabel.style.left = `${endPos}%`;
                    endLabel.dataset.year = endYear;
                    labelsContainer.appendChild(endLabel);
                }
            }
        }
        
        function updateTimelineDisplay() {
            const startEl = document.getElementById('timelineStart');
            const endEl = document.getElementById('timelineEnd');
            if (startEl) startEl.textContent = yearRange.min;
            if (endEl) endEl.textContent = yearRange.max;
        }

        // 그래프 초기화
        function initGraph() {
  // ⭐ Starfield layout tuning parameters
  const STARFIELD = {
    chargeStrength: -1500,
    distanceMin: 60,
    distanceMax: 2000,
    linkDistance: 180,
    linkStrength: 0.4,
    collidePadding: 24,
    collideStrength: 1.0,
    centerStrength: 0.03,
    axisStrength: 0.004,
    alphaDecay: 0.02,
    velocityDecay: 0.38
  };

            const container = document.querySelector('.graph-container');
            width = container.clientWidth;
            height = container.clientHeight;

            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);

            // 줌 설정 (성능 최적화)
            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', throttle((event) => {
                    g.attr('transform', event.transform);
                    currentScale = event.transform.k;
                    
                    // 지능형 성능 모드 조정
                    const nodeCount = nodes.length;
                    smartPerformanceMode = nodeCount > 1000;
                    performanceMode = nodeCount > 500 || currentScale < 0.3;
                    
                    // 효율적인 라벨 업데이트
                    requestAnimationFrame(() => {
                        updateLabelsVisibility();
                        updateNodeVisibility();
                    });
                }, 16));

            svg.call(zoom);
            g = svg.append('g');

            // 시뮬레이션 설정 (시각성 우선)
            const nodeCount = nodes.length;
            smartPerformanceMode = nodeCount > 2000; // 임계값 증가
            performanceMode = nodeCount > 1000; // 임계값 증가
            
            let forceStrength, distanceMax, alphaDecay;
            
            // 우주의 별들처럼 넓게 분산된 네트워크
            if (smartPerformanceMode) {
                forceStrength = -400;
                distanceMax = 500;
                alphaDecay = 0.04;
            } else if (performanceMode) {
                forceStrength = -600;
                distanceMax = 700;
                alphaDecay = 0.03;
            } else {
                forceStrength = -800;
                distanceMax = null;
                alphaDecay = 0.02;
            }
            
            \
simulation = d3.forceSimulation(nodes)
  .force('link', d3.forceLink(links)
    .id(d => d.id)
    .distance(STARFIELD.linkDistance)
    .strength(STARFIELD.linkStrength)
  )
  .force('charge', d3.forceManyBody()
    .strength(STARFIELD.chargeStrength)
    .distanceMin(STARFIELD.distanceMin)
    .distanceMax(STARFIELD.distanceMax)
  )
  .force('center', d3.forceCenter(width / 2, height / 2).strength(STARFIELD.centerStrength))
  .force('collision', d3.forceCollide().radius(d => (d._r || getNodeSize(d)) + STARFIELD.collidePadding)
    .strength(STARFIELD.collideStrength)
  )
  .force('x', d3.forceX(width / 2).strength(STARFIELD.axisStrength))
  .force('y', d3.forceY(height / 2).strength(STARFIELD.axisStrength))
  .alphaDecay(STARFIELD.alphaDecay)
  .alphaMin(0.001)
  .velocityDecay(STARFIELD.velocityDecay);


            renderGraph();
            document.getElementById('loading').style.display = 'none';
        }

        // 그래프 렌더링 (성능 최적화)
        function renderGraph() {
  // Cache node radius to avoid repeated getNodeSize() calls in ticks
  if (Array.isArray(nodes)) {
    nodes.forEach(d => { d._r = (typeof getNodeSize === 'function') ? getNodeSize(d) : (d._r || 6); });
  }

            // 기존 요소 제거
            g.selectAll('*').remove();

            // 성능 모드 체크 (시각성 우선)
            const nodeCount = nodes.length;
            smartPerformanceMode = nodeCount > 2000;
            performanceMode = nodeCount > 1000;
            
            // 링크 그리기 (개선된 시각 효과)
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke-width', d => {
                    if (smartPerformanceMode) {
                        return Math.min(Math.sqrt(d.weight) * 1.0 + 1, 3)
  .style('opacity', 0.5)
;
                    } else if (performanceMode) {
                        return Math.min(Math.sqrt(d.weight) * 1.2 + 1, 4.5);
                    } else {
                        return Math.min(Math.sqrt(d.weight) * 1.3 + 1.5, 6);
                    }
                })
                .style('display', smartPerformanceMode && currentScale < 0.1 ? 'none' : null);

            // 노드 그리기 (성능 최적화)
            const node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => getNodeSize(d))
                .attr('fill', d => colors[d.type])
                .style('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
  .on('mouseover', (event, d) => {
    g.selectAll('.node-label')
      .filter(l => l.id === d.id)
      .classed('visible', true)
      .classed('hovered', true);
  })
  .on('mouseout', (event, d) => {
    g.selectAll('.node-label')
      .filter(l => l.id === d.id)
      .classed('hovered', false)
      .classed('visible', l => l.type === 'service');
  })
;

            // 라벨 추가 (시각성 우선)
            const label = g.append('g')
                .selectAll('text')
                .data(nodes.filter(d => d.type === 'service'))
                .enter().append('text')
                .attr('class', 'node-label')
                .attr('dy', d => getNodeSize(d) + 18)
                .text(d => {
                    const maxLength = smartPerformanceMode ? 15 : (performanceMode ? 20 : 25)
  .classed('vis
  // Lazy label creation for non-service nodes
  const createdLabelIds = new Set();
  g.selectAll('.node-label').each(function(d){ if (d && d.id) createdLabelIds.add(d.id); });

  function ensureLabelFor(nodeDatum) {
    if (!nodeDatum || !nodeDatum.id) return;
    if (createdLabelIds.has(nodeDatum.id)) {
      // already exists
      return;
    }
    const maxLength = smartPerformanceMode ? 15 : (performanceMode ? 20 : 30);
    g.append('text')
      .datum(nodeDatum)
      .attr('class', 'node-label')
      .attr('dy', (nodeDatum._r || getNodeSize(nodeDatum)) + 18)
      .text(truncateText(nodeDatum.id, maxLength))
      .classed('visible', true);
    createdLabelIds.add(nodeDatum.id);
  }
ible', d => d.type === 'service');
                    return truncateText(d.id, maxLength);
                })
                .style('display', smartPerformanceMode && currentScale < 0.2 ? 'none' : null);

            // 이벤트 리스너
            node
                .on('mouseover', (event, d) => {
                    showTooltip(event, d);
                })
                .on('mouseout', () => {
                    hideTooltip();
                })
                .on('click', (event, d) => {
                    event.stopPropagation();
                    selectNode(d);
                });

            // 배경 클릭 시 선택 해제
            svg.on('click', () => {
                clearSelection();
            });

            // 시뮬레이션 업데이트
            simulation.nodes(nodes);
            simulation.force('link').links(links);

            simulation.on('tick', () => {
                const now = Date.now();
                if (now - lastUpdateTime < 16) return; // 60fps 제한
                lastUpdateTime = now;

                // 뷰포트 내 요소만 업데이트
                updateVisibleElements();

                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            // 시뮬레이션 시작 (성능 최적화)
            isSimulationRunning = true;
            simulation.alpha(performanceMode ? 0.8 : 1).restart();
            
            // 성능 모드에서 시뮬레이션 자동 중지
            if (performanceMode) {
                setTimeout(() => {
                    if (simulation.alpha() < 0.1) {
                        simulation.stop();
                        isSimulationRunning = false;
                    }
                }, 3000);
            }

            // 초기 모드 설정
            updateNodeVisibility();
            updateLabelsVisibility();
        }

        // 노드 크기 계산 (개선된 균형)
        function getNodeSize(d) {
            // 지능형 크기 조정
            let baseSize, maxSize, connectionFactor;
            
            if (smartPerformanceMode && nodes.length > 1000) {
                // 극대 데이터 모드
                baseSize = 4;
                maxSize = 18;
                connectionFactor = Math.sqrt(d.connections) * 1.2;
            } else if (performanceMode) {
                // 일반 성능 모드 - 시각적 품질 개선
                baseSize = 7;
                maxSize = 28;
                connectionFactor = Math.sqrt(d.connections) * 1.5;
            } else {
                // 일반 모드
                baseSize = 8;
                maxSize = 35;
                connectionFactor = Math.sqrt(d.connections) * 1.8;
            }
            
            return Math.max(baseSize, Math.min(baseSize + connectionFactor, maxSize));
        }

        // 노드 선택 및 블러 효과
        function selectNode(targetNode) {
            selectedNode = targetNode;
            
            // 연결된 노드들 찾기
            const connectedNodes = new Set([targetNode.id]);
            const connectedLinks = new Set();
            
            links.forEach(link => {
                if (link.source.id === targetNode.id || link.target.id === targetNode.id) {
                    connectedNodes.add(link.source.id);
                    connectedNodes.add(link.target.id);
                    connectedLinks.add(link);
                }
            });

            // 노드 스타일 적용
            g.selectAll('.node')
                .classed('blurred', d => !connectedNodes.has(d.id))
                .classed('highlighted', d => connectedNodes.has(d.id));

            // 링크 스타일 적용
            g.selectAll('.link')
                .classed('blurred', d => !connectedLinks.has(d))
                .classed('highlighted', d => connectedLinks.has(d));

            // 선택 해제 버튼 표시
            document.getElementById('clearSelection').classList.add('visible');
        }

        // 선택 해제 (수행용역 선택도 해제)
        function clearSelection() {
            selectedNode = null;
            
            // 수행용역 선택도 해제
            selectedServices.clear();
            showSelectedOnly = false;
            document.getElementById('showSelectedOnly').classList.remove('active');
            document.getElementById('showSelectedOnly').textContent = '선택만 보기';
            
            g.selectAll('.node')
                .classed('blurred', false)
                .classed('highlighted', false)
                .classed('service-selected', false)
                .style('display', null);

            g.selectAll('.link')
                .classed('blurred', false)
                .classed('highlighted', false)
                .style('display', null);
                
            g.selectAll('.node-label')
                .classed('service-highlighted', false);

            document.getElementById('clearSelection').classList.remove('visible');
            
            // 수행용역 브라우저 업데이트
            updateServiceCount();
            renderServiceList();
        }

        // 성능 최적화 헬퍼 함수
        function throttle(func, delay) {
            let timeoutId;
            let lastExecTime = 0;
            return function (...args) {
                const currentTime = Date.now();
                
                if (currentTime - lastExecTime > delay) {
                    func.apply(this, args);
                    lastExecTime = currentTime;
                } else {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                        lastExecTime = Date.now();
                    }, delay);
                }
            };
        }

        // 뷰포트 내 요소만 업데이트
        function updateVisibleElements() {
            if (!g) return;
            
            const transform = d3.zoomTransform(svg.node());
            const viewBox = {
                x: -transform.x / transform.k,
                y: -transform.y / transform.k,
                width: width / transform.k,
                height: height / transform.k
            };

            // 뷰포트 내 노드 필터링 (성능 모드일 때만)
            if (performanceMode) {
                visibleNodes = nodes.filter(d => 
                    d.x >= viewBox.x - 50 && 
                    d.x <= viewBox.x + viewBox.width + 50 &&
                    d.y >= viewBox.y - 50 && 
                    d.y <= viewBox.y + viewBox.height + 50
                );
            } else {
                visibleNodes = nodes;
            }
        }

        // 노드 가시성 업데이트 (시각성 우선)
        function updateNodeVisibility() {
            if (!g) return;

            const nodeSelection = g.selectAll('.node');
  nodeSelection.style('opacity', d => d.connections > 0 ? 0.95 : 0.6);
            const linkSelection = g.selectAll('.link');
  linkSelection.style('opacity', 0.4);
            const labelSelection = g.selectAll('.node-label');

            // 대부분의 경우 모든 노드 표시
            if (smartPerformanceMode && currentScale < 0.1) {
                // 극도로 축소된 경우에만 일부 제한
                nodeSelection.style('display', null);
                linkSelection.style('display', null);
                labelSelection.style('display', null);
            } else if (currentScale < 0.2) {
                // 많이 축소: 중요 노드 위주
                nodeSelection.style('display', null);
                linkSelection.style('display', null);
                labelSelection.style('display', null);
            } else {
                // 일반적인 경우: 모든 요소 표시
                nodeSelection.style('display', null);
                linkSelection.style('display', null);
                updateLabelsVisibility();
            }
        }

        // 라벨 표시 (시각성 우선)
        function updateLabelsVisibility() {
  // Keep service labels visible
  g.selectAll('.node-label').each(function(d){
    const sel = d3.select(this);
    if (d && d.type === 'service') sel.classed('visible', true);
  });
});
});
        }

        // 텍스트 자르기
        function truncateText(text, maxLength) {
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
        }

        // 툴팁 표시
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const rect = document.querySelector('.graph-container').getBoundingClientRect();
            
            tooltip.innerHTML = `
                <strong>${d.id}</strong><br>
                타입: ${getTypeLabel(d.type)}<br>
                연결: ${d.connections}개
                ${d.year ? `<br>연도: ${d.year}` : ''}
            `;
            
            tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
            tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
            tooltip.classList.add('visible');
        }

        // 툴팁 숨기기
        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        // 타입 라벨 반환
        function getTypeLabel(type) {
            const labels = {
                contract: '계약명',
                service: '수행용역'
            };
            return labels[type] || type;
        }

        // 드래그 이벤트 (성능 최적화)
        function dragstarted(event, d) {
            if (!event.active && !isSimulationRunning) {
                simulation.alphaTarget(0.3).restart();
                isSimulationRunning = true;
            }
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) {
                simulation.alphaTarget(0);
                // 성능 모드에서 빠른 종료
                if (performanceMode) {
                    setTimeout(() => {
                        simulation.stop();
                        isSimulationRunning = false;
                    }, 1000);
                }
            }
            d.fx = null;
            d.fy = null;
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            // 검색 (수행용역 필터와 연동)
            document.getElementById('searchInput').addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                
                // 수행용역 검색 결과도 업데이트
                if (query) {
                    // 검색어와 매칭되는 수행용역 자동 하이라이트
                    const matchingServices = allServices.filter(service => 
                        service.toLowerCase().includes(query)
                    );
                    
                    if (matchingServices.length > 0 && matchingServices.length <= 3) {
                        // 매칭되는 수행용역이 3개 이하면 자동 선택
                        selectedServices.clear();
                        matchingServices.forEach(service => selectedServices.add(service));
                        updateServiceHighlighting();
                        updateServiceCount();
                        renderServiceList();
                    }
                } else {
                    // 검색어가 비어있으면 수행용역 선택 해제
                    if (selectedServices.size > 0) {
                        selectedServices.clear();
                        updateServiceHighlighting();
                        updateServiceCount();
                        renderServiceList();
                    }
                }
                
                applyFilters();
            });

            // 타임라인 룰러 드래그 이벤트
            let isDragging = false;
            let dragTarget = null;
            
            // 드래그 시작
            document.addEventListener('mousedown', (e) => {
                const handle = e.target.closest('.range-handle');
                if (handle) {
                    isDragging = true;
                    dragTarget = handle;
                    e.preventDefault();
                }
            });
            
            // 드래그 중
            document.addEventListener('mousemove', (e) => {
                if (!isDragging || !dragTarget) return;
                
                const ruler = document.querySelector('.timeline-ruler');
                if (!ruler) return;
                
                const rect = ruler.getBoundingClientRect();
                const x = e.clientX - rect.left - 15; // 15px padding
                const width = rect.width - 30; // 양쪽 padding 제외
                const percentage = Math.max(0, Math.min(100, (x / width) * 100));
                
                const minYear = Math.min(...availableYears);
                const maxYear = Math.max(...availableYears);
                const totalYears = maxYear - minYear;
                const selectedYear = Math.round(minYear + (percentage / 100) * totalYears);
                
                if (dragTarget.classList.contains('range-start')) {
                    yearRange.min = Math.max(minYear, Math.min(selectedYear, yearRange.max));
                } else {
                    yearRange.max = Math.min(maxYear, Math.max(selectedYear, yearRange.min));
                }
                
                updateRangeSelection(minYear, maxYear, yearRange.min, yearRange.max);
                updateTimelineDisplay();
                applyFilters();
            });
            
            // 드래그 종료
            document.addEventListener('mouseup', () => {
                isDragging = false;
                dragTarget = null;
            });
            

            // 노드 타입 필터 (수정됨 - 발주처 제거)
            document.getElementById('nodeTypeFilters').addEventListener('click', (e) => {
                if (e.target.classList.contains('filter-btn')) {
                    document.querySelectorAll('#nodeTypeFilters .filter-btn').forEach(btn => 
                        btn.classList.remove('active')
                    );
                    e.target.classList.add('active');
                    applyFilters();
                }
            });

            // 줌 컨트롤
            document.getElementById('zoomIn').addEventListener('click', () => {
                svg.transition().duration(performanceMode ? 200 : 500).call(zoom.scaleBy, 1.2);
            });

            document.getElementById('zoomOut').addEventListener('click', () => {
                svg.transition().duration(performanceMode ? 200 : 500).call(zoom.scaleBy, 0.8);
            });

            document.getElementById('resetZoom').addEventListener('click', () => {
                // 성능 모드는 노드 수에 따라 자동 결정되도록 유지
                svg.transition().duration(800).call(zoom.transform, d3.zoomIdentity);
                setTimeout(() => updateNodeVisibility(), 1000);
            });

            // 선택 해제 버튼
            document.getElementById('clearSelection').addEventListener('click', () => {
                clearSelection();
            });

            // 윈도우 리사이즈 (성능 최적화)
            window.addEventListener('resize', throttle(() => {
                const container = document.querySelector('.graph-container');
                width = container.clientWidth;
                height = container.clientHeight;
                
                svg.attr('width', width).attr('height', height);
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                
                if (!isSimulationRunning) {
                    simulation.alpha(0.1).restart();
                    isSimulationRunning = true;
                    setTimeout(() => {
                        simulation.stop();
                        isSimulationRunning = false;
                    }, 1000);
                }
            }, 250));
        }

        // 필터 적용
        function applyFilters() {
            const searchQuery = document.getElementById('searchInput').value.toLowerCase();
            const activeType = document.querySelector('#nodeTypeFilters .filter-btn.active')?.dataset.type;

            // 데이터 필터링
            filteredData = allData.filter(d => {
                const matchesSearch = !searchQuery || 
                    d.contract.toLowerCase().includes(searchQuery) ||
                    d.service.toLowerCase().includes(searchQuery);

                const year = parseInt(d.year);
                const matchesYear = !isNaN(year) && year >= yearRange.min && year <= yearRange.max;

                return matchesSearch && matchesYear;
            });

            // 네트워크 데이터 재생성
            createNetworkData();

            // 노드 타입 필터링
            if (activeType !== 'all') {
                let allowedTypes = [];
                
                switch(activeType) {
                    case 'contract-only':
                        allowedTypes = ['contract'];
                        break;
                    case 'service-only':
                        allowedTypes = ['service'];
                        break;
                }
                
                nodes = nodes.filter(node => allowedTypes.includes(node.type));
                links = links.filter(link => {
                    const sourceNode = nodes.find(n => n.id === link.source);
                    const targetNode = nodes.find(n => n.id === link.target);
                    return sourceNode && targetNode;
                });
            }

            // 선택 해제
            clearSelection();

            // 그래프 재렌더링
            renderGraph();
            updateStats();
        }

        // 통계 업데이트
        function updateStats() {
            document.getElementById('totalNodes').textContent = nodes.length.toLocaleString();
            document.getElementById('totalLinks').textContent = links.length.toLocaleString();
            document.getElementById('visibleNodes').textContent = nodes.length.toLocaleString();
        }

        // 수행용역 브라우저 초기화
        function initializeServiceBrowser() {
            // 모든 수행용역 추출 및 정렬
            const serviceSet = new Set();
            allData.forEach(d => {
                if (d.service && d.service.trim()) {
                    serviceSet.add(d.service.trim());
                }
            });
            
            allServices = Array.from(serviceSet).sort((a, b) => a.localeCompare(b, 'ko'));
            
            console.log(`수행용역 ${allServices.length}개 추출 완료:`, allServices);
            
            // 수행용역 리스트 렌더링
            renderServiceList();
            
            // 이벤트 리스너 설정
            setupServiceBrowserEvents();
            
            // 카운트 업데이트
            updateServiceCount();
        }

        // 수행용역 리스트 렌더링
        function renderServiceList(searchQuery = '') {
            const serviceList = document.getElementById('serviceList');
            const filteredServices = allServices.filter(service => 
                service.toLowerCase().includes(searchQuery.toLowerCase())
            );
            
            serviceList.innerHTML = '';
            
            filteredServices.forEach(service => {
                // 해당 수행용역과 연결된 계약 수 계산
                const contractCount = allData.filter(d => d.service === service).length;
                
                const serviceItem = document.createElement('div');
                serviceItem.className = 'service-item';
                serviceItem.innerHTML = `
                    <input type="checkbox" class="service-checkbox" data-service="${service}" ${selectedServices.has(service) ? 'checked' : ''}>
                    <span class="service-label ${selectedServices.has(service) ? 'selected' : ''}">${service}</span>
                    <span class="service-count">${contractCount}</span>
                `;
                
                if (selectedServices.has(service)) {
                    serviceItem.classList.add('highlighted');
                }
                
                serviceList.appendChild(serviceItem);
            });
        }

        // 수행용역 브라우저 이벤트 설정
        function setupServiceBrowserEvents() {
            // 검색 기능
            const serviceSearch = document.getElementById('serviceSearch');
            serviceSearch.addEventListener('input', (e) => {
                const query = e.target.value;
                renderServiceList(query);
                
                // 검색 결과에 따른 플레이스홀더 업데이트
                const matchingCount = allServices.filter(service => 
                    service.toLowerCase().includes(query.toLowerCase())
                ).length;
                
                if (query && matchingCount === 0) {
                    e.target.style.borderColor = '#ef4444';
                    e.target.placeholder = '일치하는 수행용역이 없습니다';
                } else {
                    e.target.style.borderColor = query ? '#10b981' : '#d1d5db';
                    e.target.placeholder = query ? `${matchingCount}개 수행용역 발견` : '수행용역 검색...';
                }
            });

            // 체크박스 클릭 이벤트 (이벤트 위임)
            const serviceList = document.getElementById('serviceList');
            serviceList.addEventListener('change', (e) => {
                if (e.target.classList.contains('service-checkbox')) {
                    const service = e.target.dataset.service;
                    const isChecked = e.target.checked;
                    
                    if (isChecked) {
                        selectedServices.add(service);
                    } else {
                        selectedServices.delete(service);
                    }
                    
                    updateServiceHighlighting();
                    updateServiceCount();
                    renderServiceList(serviceSearch.value);
                }
            });

            // 라벨 클릭으로 체크박스 토글
            serviceList.addEventListener('click', (e) => {
                if (e.target.classList.contains('service-label')) {
                    const checkbox = e.target.parentElement.querySelector('.service-checkbox');
                    checkbox.click();
                }
            });

            // 컨트롤 버튼들
            document.getElementById('selectAllServices').addEventListener('click', () => {
                allServices.forEach(service => selectedServices.add(service));
                updateServiceHighlighting();
                updateServiceCount();
                renderServiceList(serviceSearch.value);
            });

            document.getElementById('clearAllServices').addEventListener('click', () => {
                selectedServices.clear();
                updateServiceHighlighting();
                updateServiceCount();
                renderServiceList(serviceSearch.value);
            });

            document.getElementById('showSelectedOnly').addEventListener('click', (e) => {
                showSelectedOnly = !showSelectedOnly;
                e.target.classList.toggle('active');
                e.target.textContent = showSelectedOnly ? '모두 보기' : '선택만 보기';
                updateServiceHighlighting();
            });
        }

        // 선택된 수행용역 수 업데이트
        function updateServiceCount() {
            const count = selectedServices.size;
            const total = allServices.length;
            document.getElementById('selectedServiceCount').textContent = `${count}/${total}`;
        }

        // 수행용역 선택에 따른 그래프 하이라이팅
        function updateServiceHighlighting() {
            if (!g) return; // 그래프가 아직 초기화되지 않은 경우

            // 선택된 수행용역이 없으면 모든 노드를 정상 상태로
            if (selectedServices.size === 0) {
                g.selectAll('.node')
                    .classed('blurred', false)
                    .classed('highlighted', false)
                    .classed('service-selected', false);
                
                g.selectAll('.link')
                    .classed('blurred', false)
                    .classed('highlighted', false);
                    
                g.selectAll('.node-label')
                    .classed('service-highlighted', false);
                
                return;
            }

            // 선택된 수행용역과 관련된 노드들 찾기
            const selectedServiceNodes = new Set();
            const connectedContractNodes = new Set();
            const highlightedLinks = new Set();

            // 선택된 수행용역 노드들과 연결된 계약들 찾기
            nodes.forEach(node => {
                if (node.type === 'service' && selectedServices.has(node.id)) {
                    selectedServiceNodes.add(node.id);
                }
            });

            // 링크를 통해 연결된 계약들 찾기
            links.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                
                if (selectedServiceNodes.has(sourceId)) {
                    connectedContractNodes.add(targetId);
                    highlightedLinks.add(link);
                } else if (selectedServiceNodes.has(targetId)) {
                    connectedContractNodes.add(sourceId);
                    highlightedLinks.add(link);
                }
            });

            // 모든 관련 노드들을 합치기
            const allRelatedNodes = new Set([...selectedServiceNodes, ...connectedContractNodes]);

            // "선택만 보기" 모드 처리
            if (showSelectedOnly) {
                g.selectAll('.node')
                    .style('display', d => allRelatedNodes.has(d.id) ? null : 'none');
                
                g.selectAll('.link')
                    .style('display', d => highlightedLinks.has(d) ? null : 'none');
            } else {
                // 모든 노드를 다시 표시
                g.selectAll('.node')
                    .style('display', null);
                
                g.selectAll('.link')
                    .style('display', null);
                
                // 하이라이팅 적용
                g.selectAll('.node')
                    .classed('blurred', d => !allRelatedNodes.has(d.id))
                    .classed('highlighted', d => allRelatedNodes.has(d.id))
                    .classed('service-selected', d => selectedServiceNodes.has(d.id));
                
                g.selectAll('.link')
                    .classed('blurred', d => !highlightedLinks.has(d))
                    .classed('highlighted', d => highlightedLinks.has(d));
            }

            // 선택된 수행용역과 연결된 노드들의 라벨을 강조
            g.selectAll('.node-label')
                .classed('service-highlighted', d => allRelatedNodes.has(d.id));
                
            // 선택 해제 버튼 표시
            document.getElementById('clearSelection').classList.add('visible');
        }
    </script>
</body>
</html>
